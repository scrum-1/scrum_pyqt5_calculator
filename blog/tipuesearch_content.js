var tipuesearch = {"pages":[{"title":"About","text":"2017Fall 機械設計工程系 CADP & CP 課程倉儲: https://mde1a1.kmol.info/2017fall 課程投影片: https://mde1a1.kmol.info/2017fall/doc/trunk/index.html 課程網誌: https://mde1a1.kmol.info/2017fall/doc/trunk/blog/","tags":"misc","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/pages/about/"},{"title":"導入 Let's Encrypt 數位簽章","text":"Let's encrypt 從 2016 年 4 月起開始免費推廣自動化的數位簽章技術, 儘管每次僅有 90 天的效期, 但可採用自動化流程更新, 讓網站與用戶間的資料傳輸更容易保全. Nginx https 數位簽章 將 Let's encrypt 技術套用到 Nginx 網站, 配合 Ubuntu 16.04 操作系統, 只要依照 certbot 所提供的流程, 進行安裝: $ sudo apt-get update $ sudo apt-get install software-properties-common $ sudo add-apt-repository ppa:certbot/certbot $ sudo apt-get update $ sudo apt-get install python-certbot-nginx 然後透過 $ sudo certbot --nginx 讓 certbot 自動設定所需的 https 連線參數, 即可取得 fullchain.pem 與 privkey.pem 等兩數位公鑰與私鑰檔案. 更新簽章時, 則透過 $ sudo certbot renew 取得新的公私鑰檔案. Stunnel 以制式數位簽章啟動 取得制式的數位簽章後, 為了讓 Fossil SCM 能透過 Stunnel 以 https 連線, 因此前面被 certbot 修改的 /etc/nginx/sites-available/default 設定檔案, 必須回復到原狀態, 意即 http 的連線由 Nginx 回應, 而 https 則轉由 Stunnel 與 Fossil SCM 處理, 且 Nginx 採 301 redirect 設定, 收到請求後, 直接轉給 Fossil SCM 處理. default 設定: server { listen 80; server_name mde1a1.kmol.info; rewrite &#94;/(.*)$ https://mde1a1.kmol.info/$1 permanent; }","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-let-us-encrypt-intro.html"},{"title":"視窗計算機程式開發","text":"Python3 + PyQt5 計算機程式開發 PyQt5 計算機程式說明 按鍵分類 0 ~9 數字按建, 點按後由 digitClicked() 方法槽承接處理 直接運算元, 包括 Sqrt, x&#94;2 與 1/x, 點按後由 unaryOperatorClicked() 方法槽承接處理 加或減運算元, 包括 + 與 - 運算, 點按後由 additiveOperatorClicked() 方法槽承接處理 乘或除運算元, 包括 * 與 / 運算, 點按後由 multiplicativeOperatorClicked() 方法槽承接處理 其餘按鍵則各自以特定的方法槽承接處理 變數與運算流程考量 數字按鍵以 zero, one, two, three, four, five, six, seven, eight, nine 命名 顯示幕以 display 命名 等號以 equalButton 命名 與 MS, M+, 或 MC 按鍵相關的計算機記憶體數值, 存入 sumInMemory 變數對應的記憶空間 以 sumSoFar 儲存累計數值, 使用者按下等號後, sumSoFar 重新計算結果, 並顯示在 display 幕, Clear All 按鍵則重置 sumSoFar 為 0 以 factorSoFar 儲存乘或除運算子運算過程所得的暫存數值 以 pendingAdditiveOperator 儲存使用者最後點按的加或減運算子字串 以 pendingMultiplicativeOperator 儲存使用者最後點按的乘或除運算子字串 以 waitingForOperand 界定使用者是否處理運算數輸入階段, 若 waitingForOperand 為 True, 表示計算機正在等待使用者\"開始\"輸入運算數 waitingForOperand 起始值為 True, 只有重新進入 digitClicked 方法, display 才會 clear(), 否則在顯示幕非為 0 的情況下, 將堆疊數字字串 因為考量先乘除後加減運算順序, 將加減與乘除處理方法分開, 若使用者輸入加減運算子後, 緊接乘除運算子, 計算機會先乘除運算後再加減 直接運算元可以在使用者按下按鍵後, 直接對 display 中的數值進行處理, 無需其他暫存需求 pendingAdditiveOperator, pendingMultiplicativeOperator, sumSoFar, factorSoFar 與 waitingForOperand, 在 Dialog 類別建構子中設定起始值 數字按鍵點按處理 使用者點按數字按鍵, 將會送出該按鍵的 clicked() 訊號 按鍵的 clicked() 訊號將會根據設定, 觸發 digitClicked() 方法槽 由於 PyQt5 的 Push Button 以 Qt5 中的 QObject::sender() 送出訊號, 此函式會傳回 sender 作為 QObject 的指標 因為此一與 Push Button 配合的 sender 為 Button 物件, 因此可以在 digitClicked() 函式中, 利用 sender().text() 取得按鍵的 text 字串 假如使用者點按 0, display 顯示字串 0, 但是若一開始輸入兩個以上的 0, digitClicked() 應該仍只顯示 0 字串 但是若計算機處於等待新運算數輸入時 (以 waitingForOperand 判定), 新數字在顯示前, display 應該要清除先前所顯示的數字 最後, 除了在顯示幕為 0 之後的 0 按鍵輸入, digitClicked() 方法槽不會繼續判定是否清除顯示幕或堆疊數字字串外, 所按的數字將會堆疊顯示 直接運算按鍵處理 Sqrt, x&#94;2 與 1/x 等按鍵的處理方法為 unaryOperatorClicked(), 與數字按鍵的點按回應相同, 透過 sender().text() 取得按鍵上的 text 字串 unaryOperatorClicked() 方法隨後根據 text 判定運算子後, 利用 display 上的運算數進行運算後, 再將結果顯示在 display 顯示幕 若進行運算 Sqrt 求數值的平方根時, 顯示幕中為負值, 或 1/x 運算時, x 為 0, 都視為無法處理的情況, 以呼叫 abortOperation() 處理 abortOperation() 方法則重置所有起始變數, 並在 display 中顯示 \"####\" 直接運算子處理結束前, 運算結果會顯示在 display 中, 而且運算至此告一段落, 計算機狀態應該要回復到等待新運算數的階段, 因此 waitingForOperand 要重置為 True 加或減按鍵處理 使用者按下加或減運算子按鍵時, 程式設定以 additiveOperatorClicked() 處理 進入 additiveOperatorClicked() 後, 必須先查是否有尚未運算的乘或除運算子, 因為必須先乘除後才能加減 先處理乘與除運算後, 再處理加或減運算後, 將 sumSoFar 顯示在 display 後, 必須重置 sumSoFar 為 0, 表示運算告一段落 乘或除按鍵處理 使用者按下乘或除運算子按鍵時, 程式設定以 multiplicativeOperatorClicked() 處理 進入 multiplicativeOperatorClicked() 後, 無需檢查是否有尚未運算的加或減運算子, 因為乘除運算有優先權 先處理乘與除運算後, 再處理加或減運算, 將 sumSoFar 顯示在 display 後, 必須重置 sumSoFar 為 0, 表示運算告一段落 小數點按鍵處理 使用者按下小數點按鍵後, 以 pointClicked() 方法處理, 直接在 display 字串中加上 \".\" 字串 數值變號按鍵處理 使用者按下變號按鍵後, 由 changeSignClicked() 處理, 若顯示幕上為正值, 則在 display 字串最前面, 疊上 \"-\" 字串 假如顯示幕上為負值, 則設法移除 display 上字串最前方的 \"-\" 字元 退格按鍵處理 使用者按下退格按鍵後, 由 backspaceClicked() 處理, 這時可以利用 Python 字串數列中的 [:-1], 保留除了最後一個字元的字串 離開 backspaceClicked() 前 ,將顯示幕中原有字串的 [:-1] 字串, 顯示在 display 上 若退格後 display 上為空字串, 則顯示 0, 並且將 waitingForOperand 起始設為 True, 表示等待新運算數中 清除按鍵處理 使用者按下 Clear 按鍵後, 以 clear() 方法處理, 進入函式後, 將現有的運算數重置為 0 離開 clear() 前, 將 waitingForOperand 起始設為 True, 表示等待新運算數中 ClearAll 按鍵, 則將所有變數全部重置為起始狀態 記憶體按鍵處理 clearMemory() 方法與 \"MC\" 按鍵對應, 清除記憶體中所存 sumInMemory 設為 0 readMemory() 方法與 \"MR\" 按鍵對應, 功能為讀取記憶體中的數值, 因此將 sumInMemory 顯示在 display, 作為運算數 setMemory() 方法則與 \"MS\" 按鍵對應, 功能為設定記憶體中的數值，因此取 display 中的數字, 存入 sumInMemory addToMemory() 方法與 \"M+\" 按鍵對應, 功能為加上記憶體中的數值, 因此將 sumInMemory 加上 display 中的數值 因為 setMemory() 與 addToMemory() 方法, 都需要取用 display 上的數值, 因此必須先呼叫 equalClicked(), 以更新 sumSoFar 與 display 上的數值 calculate() 方法 calculate() 方法中的運算, 以 rightOperand 為右運算數 當執行加或減運算時, 左運算數為 sumSoFar 當執行乘或除運算時, 左運算數為 factorSoFar 若運算過程出現除與 0 時, 將會回傳 False PyQt5 參考資料 Qt5 - sender() sip - sip: sender() PyQt5 計算機程式原始碼 # Dialog 類別同時繼承 QDialog 與 Ui_Dialog 類別 class Dialog(QDialog, Ui_Dialog): \"\"\" Class documentation goes here. (若有類別相關說明文件內容, 放在此處) \"\"\" def __init__(self, parent=None): \"\"\" Constructor (類別建構子) @param parent reference to the parent widget @type QWidget \"\"\" # 利用 super 類別調用 parent 類別中的建構子 super(Dialog, self).__init__(parent) # 上一行在 Python3 可以寫為 super().__init__() # 利用 Ui_Dialog 類別中的 setupUi 方法, 以 self 視窗部件建立使用者介面 self.setupUi(self) # 以上程式碼由 Eric6 表單頁面中的滑鼠右鍵, Generate Dialog Code 指令產生 # 當多個 signal 同時指向同一個 slot 處理時, 採用 for loop num_button = [self.one, self.two, \\ self.three, self.four, self.five, self.six, self.seven, self.eight, self.nine, self.zero] # 用於產生加號與減號 signals 與 slots 用的數列 plus_minus = [self.plusButton, self.minusButton] # 用於產生乘號與除號 signals 與 slots 用的數列 multiply_divide = [self.timesButton, self.divisionButton] #self.one.clicked.connect(self.number) # 數字按鍵的 signals 與 slots 設定 for i in num_button: i.clicked.connect(self.digitClicked) # 加減鍵的 signals 與 slogts 設定 for i in plus_minus: i.clicked.connect(self.additiveOperatorClicked) # 等於按鍵的 signal 與 slot 設定 self.equalButton.clicked.connect(self.equalClicked) # 清除 self.clearButton.clicked.connect(self.clear) # 全部清除 self.clearAllButton.clicked.connect(self.clearAll) # 清除記憶 self.clearMemoryButton.clicked.connect(self.clearMemory) # 讀取記憶 self.readMemoryButton.clicked.connect(self.readMemory) # 設定記憶 self.setMemoryButton.clicked.connect(self.setMemory) # 按下小數點 self.pointButton.clicked.connect(self.pointClicked) # 按下變號 self.changeSignButton.clicked.connect(self.changeSignClicked) # 按下上一步 self.backspaceButton.clicked.connect(self.backspaceClicked) # 加入記憶體 self.addToMemoryButton.clicked.connect(self.addToMemory) # 單一運算子 unaryOperator = [self.squareRootButton, self.powerButton, self.reciprocalButton ] for i in unaryOperator: i.clicked.connect(self.unaryOperatorClicked) # 乘與除按建的 signals 與 slots 設定 for i in multiply_divide: i.clicked.connect(self.multiplicativeOperatorClicked) # 等待運算的加或減 self.pendingAdditiveOperator = '' # sumSoFar 儲存運算流程中所累計的數值 # 當使用者按下 = 後, sumSoFar 重新計算並將數字顯示在 display 區 # 當使用者按下 Clear All, sumSoFar 將重置回 0 self.sumSoFar = 0.0 # 起始時, 等待使用者輸入運算數值變數為真 self.waitingForOperand = True # sumInMemory 儲存計算機記憶體中的值, 配合 MS, M+, 或 MC 按鈕使用 self.sumInMemory = 0.0 # factorSoFar 暫存按下乘或除運算時的數值 self.factorSoFar = 0.0 # 等待運算的乘或除 self.pendingMultiplicativeOperator = '' def digitClicked(self): # sender() 為使用者點擊按鈕時送出的按鈕指標類別, 在此利用此按鍵類別建立案例 # 所建立的 clickedButton 即為當下使用者所按下的按鈕物件 clickedButton = self.sender() # text() 為利用按鈕物件的 text 方法取得該按鈕上所顯示的 text 字串 digitValue = int(clickedButton.text()) # when user clicks 0.0 if self.display.text() == '0' and digitValue == 0.0: return # if under digit input process, clear display for the very first beginning # waitingForOperand 為 True 已經點按運算數值按鈕 if self.waitingForOperand: # 清除 display self.display.clear() # 將判斷是否已經點按運算數值按鈕的判斷變數重新設為 False self.waitingForOperand = False # 利用 setText() 設定 LineEdit 元件顯示字串, 利用 text() 取出目前所顯示的字串, 同時也可利用 text() 擷取按鈕物件上顯示的字串 #self.display.setText(self.display.text() + self.sender().text()) self.display.setText(self.display.text() + str(digitValue)) def additiveOperatorClicked(self): # 確定按下加或減 clickedButton = self.sender() # 確定運算子, 為加或減 clickedOperator = clickedButton.text() # 點按運算子之前在 display 上的數字, 為運算數 operand = float(self.display.text()) # 納入乘與除之後的先乘除後加減運算邏輯, 且納入連續按下乘或除可累計運算 if self.pendingMultiplicativeOperator: if not self.calculate(operand, self.pendingMultiplicativeOperator): self.abortOperation() return self.display.setText(str(self.factorSoFar)) operand = self.factorSoFar self.factorSoFar = 0.0 self.pendingMultiplicativeOperator = '' # 假如有等待運算的加或減, 進入執行運算 # 且納入連續按下加或減時, 可以目前的運算數及運算子累計運算 if self.pendingAdditiveOperator: if not self.calculate(operand, self.pendingAdditiveOperator): self.abortOperation() return # 顯示目前的運算結果 self.display.setText(str(self.sumSoFar)) else: # 假如 self.pendingAdditiveOperator 為 False, 則將運算數與 self.fumSoFar 對應 self.sumSoFar = operand # 能夠重複按下加或減, 以目前的運算數值執行重複運算 self.pendingAdditiveOperator = clickedOperator # 進入等待另外一個運算數值的階段, 設為 True 才會清空 LineEdit self.waitingForOperand = True # 處理使用者按下乘或除按鍵時的 slot 方法 def multiplicativeOperatorClicked(self): clickedButton = self.sender() clickedOperator = clickedButton.text() # 將按鈕顯示的 text 轉為浮點數 operand = float(self.display.text()) # 若連續按下乘或除, 則以目前的運算數與運算子執行運算 if self.pendingMultiplicativeOperator: if not self.calculate(operand, self.pendingMultiplicativeOperator): self.abortOperation() return # 將目前乘或除的累計運算數顯示在 display 上 self.display.setText(str(self.factorSoFar)) else: self.factorSoFar = operand # 能夠重複按下乘或除, 以目前的運算數值執行重複運算 self.pendingMultiplicativeOperator = clickedOperator self.waitingForOperand = True def unaryOperatorClicked(self): clickedButton = self.sender() clickedOperator = clickedButton.text() operand = float(self.display.text()) if clickedOperator == \"Sqrt\": if operand < 0.0: self.abortOperation() return result = math.sqrt(operand) elif clickedOperator == \"X&#94;2\": result = math.pow(operand, 2.0) elif clickedOperator == \"1/x\": if operand == 0.0: self.abortOperation() return result = 1.0 / operand self.display.setText(str(result)) self.waitingForOperand = True def equalClicked(self): # 從 display 取的運算數值 operand = float(self.display.text()) # 先乘除的運算處理 if self.pendingMultiplicativeOperator: if not self.calculate(operand, self.pendingMultiplicativeOperator): self.abortOperation() return # factorSoFar 為乘或除運算所得之暫存數值 operand = self.factorSoFar self.factorSoFar = 0.0 self.pendingMultiplicativeOperator = '' # 若有等待加或減的運算子, 執行運算 if self.pendingAdditiveOperator: if not self.calculate(operand, self.pendingAdditiveOperator): self.abortOperation() return self.pendingAdditiveOperator = '' else: self.sumSoFar = operand self.display.setText(str(self.sumSoFar)) self.sumSoFar = 0.0 self.waitingForOperand = True # 右運算數與等待運算子當作輸入 def calculate(self, rightOperand, pendingOperator): # 進入計算流程時, 用目前輸入的運算數值與 self.sumSoFar 執行計算 if pendingOperator == \"+\": self.sumSoFar += rightOperand elif pendingOperator == \"-\": self.sumSoFar -= rightOperand elif pendingOperator == \"*\": self.factorSoFar *= rightOperand elif pendingOperator == \"/\": if rightOperand == 0.0: return False self.factorSoFar /= rightOperand return True def pointClicked(self): if self.waitingForOperand: self.display.setText('0') if \".\" not in self.display.text(): self.display.setText(self.display.text() + \".\") self.waitingForOperand = False def changeSignClicked(self): text = self.display.text() value = float(text) if value > 0.0: text = \"-\" + text elif value < 0.0: text = text[1:] self.display.setText(text) def backspaceClicked(self): if self.waitingForOperand: return text = self.display.text()[:-1] if not text: text = '0' self.waitingForOperand = True self.display.setText(text) # clearButton 按鍵的處理方法 def clear(self): # 在等待運算數階段, 直接跳出 slot, 不會清除顯示幕 if self.waitingForOperand: return self.display.setText('0') # 清除顯示幕後, 重置等待運算數狀態變數 self.waitingForOperand = True # clearAllButton 按鍵處理方法 def clearAll(self): self.sumSoFar = 0.0 self.factorSoFar = 0.0 self.pendingAdditiveOperator = '' self.pendingMultiplicativeOperator = '' self.display.setText('0') self.waitingForOperand = True def clearMemory(self): self.sumInMemory = 0.0 def readMemory(self): self.display.setText(str(self.sumInMemory)) self.waitingForOperand = True def setMemory(self): self.equalClicked() self.sumInMemory = float(self.display.text()) def addToMemory(self): self.equalClicked() self.sumInMemory += float(self.display.text()) def abortOperation(self): self.clearAll() self.display.setText(\"####\")","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-windows-calculator-development.html"},{"title":"Github 協同倉儲","text":"在進入計算機程式與電腦輔助設計實習第十二週課程時, 將請各學員利用學校配發的電子郵箱申請 Github 帳號, 目的是以小組協同的模式, 執行各自的期末專案. Git 與 Github Pages Git for Windows 已經包含在可攜程式系統中, 只要在 start.bat 啟動後所帶出的命令列中輸入 git 即可使用, 而 Github 為雲端上提供 Git 伺服器的服務商, 只要公開所建立的倉儲內容, 可以免費使用. 首先建立個人的 Github 帳號後, 建立練習用的倉儲, 並且將分支內定為 gh-pages, 因為之後會將目前位於 Fossil SCM 伺服器中的網際投影片與網誌系統, 同步到個人的 Github 期末專案倉儲中, 因此需要使用 gh-pages 分支, 用瀏覽器擷取 \"帳號.github.io/倉儲\" 網址上的資料. 以下為上課所錄製的說明教學影片: 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第十一週第一部分, 說明如何在 Github 建立倉儲, 如何利用 gh-pages 分支伺服 index.html from 國立虎尾科技大學機械設計工程系 on Vimeo . 接著, 在兩門課程中, 都需要以分組進行協同期末專案, 因此必須練習將其他組員設為協同者的操作, 以下為相關教學影片: 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第十一週第二部分, 說明如何在 Github 倉儲中新增協同者, 以及協同者如何接受邀請. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第十二週第一部分, 說明如何設定 git clone 的連線條件, 以及視窗程式在機電系統控制上的應用. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第十二週第二部分, 說明如何在 Qt Design 所產生的對話框程式中加入數字顯示邏輯. from 國立虎尾科技大學機械設計工程系 on Vimeo . 計算機程式期末示範倉儲 計算機程式的期末專案為一般簡易式的視窗計算機程式開發， 示範倉儲位於 https://github.com/scrum-1/scrum_pyqt5_calculator 電腦輔助設計實習示範倉儲 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第十一週第一部分, 說明如何利用 Github 倉儲執行各小組的期末機電資協同專案. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第十一週第二部分, 在期末機電資協同專案範例中, 加入感測器與控制用視窗程式示範 from 國立虎尾科技大學機械設計工程系 on Vimeo . 電腦輔助設計實習的期末專案則為可循環運作的鋼球運動系統, 示範倉儲位於 https://github.com/scrum-1/scrum_cadp_final","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-github-pages.html"},{"title":"事件導向程式設計","text":"目前正在進行中的普通計算機程式設計, 採用 PyQt5 與 Python3 建立, 預計採用事件導向的方式完成. 計算機視窗介面 PyQt5 普通計算機視窗介面: 10 個數字鍵, 分別為 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 使用者按下個數字鍵, 將會在顯示幕中顯示該數字值 小數點按鍵 ., 按下後顯示小數點 加號按鍵 +, 按下後進行兩數相加 減號按鍵 -, 按下後進行兩數相減 乘號按鍵 *, 按下後進行兩數相乘 除號按鍵 /, 按下後進行兩數相除 等於按鍵 =, 將運算結果列在顯示幕 清除顯示幕按鍵 C, 清除顯示幕內容並重置暫存資料 首先, 重複按數字鍵, 數字會進位, 例如: 按下兩次 1, 表示輸入 11 但是, 若目前顯示幕為 0, 則再按 0 並不會進位成為 00, 而仍然顯示 0, 而且若初始顯示幕為 0, 使用者按下運算數時, 顯示幕應該會清除, 然後配合使用者輸入的數字顯示. 因此按數字鍵的處理方法, 必須判斷: 是否在等待輸入運算數階段, 若是則必須刷新顯示幕, 而且改變判斷狀態, 因為在初始時, 等待輸入運算數判斷變數為真, 一旦已經輸入數值, 則該變數必須重置 顯示幕是否為 0 或 0.0, 這時若再輸入 0 則數值並不會累計, 而是維持原先顯示的 0 狀態 表示計算機經歷狀態改變, 而且在不同狀態下會有不同表現. 按下 C 清除螢幕, 重置各暫存值, 這時顯示幕為 0, 按一下 5, 則顯示幕中的 0 由 5 取代, 若再按一個 5, 則應該顯示 55, 表示可以字串堆疊的方式, 將原先顯示幕中的 5 字串, 再附加字串 5, 即可成為 55. 接著若按下 +, 則顯示幕上仍顯示 55, 若在 + 號之後, 再按下 3, 則顯示幕已經不能再以附加字串的方式處理, 變成 553, 而應該只顯示 3, 而且若接下來按下 =, 之前的 55 應該要在顯示 3 之前暫存, 以便能夠在按下 = 時, 完成 55 + 3 的運算, 並且將答案 58 列在顯示幕上. 因此, 若單純的兩數相加, 狀態分為\"等待輸入運算\", \"運算子\", 顯示幕中的數值以及目前的暫存值, 以 55 + 3 = 58, 總共經歷: 一開始顯示幕為 0, \"等待輸入運算數\" 變數為 True, 累加暫存變數值為 0. 使用者輸入第一個 5, 進入數字按鍵處理方法, 因\"等待輸入運算數\"為真, 因此刷新顯示幕, 重置\"等待輸入運算數\", 在顯示幕中列出 5. 使用者輸入第二個 5, 再次進入數字按鍵處理方法, 因\"等待輸入運算數\"為假 (因為正處於運算數輸入階段), 因此不會刷新顯示幕, 而是將第二次輸入的 5 與顯示幕上的 5 堆疊, 顯示 55. 使用者輸入 +, 這時顯示幕畫面仍顯示 55, 但是\"運算子\"變數存入 \"+\" 字串, 顯示幕中的 55 數值暫時放入累加變數, 成為左運算數, 運算子為 +, 離開之前, 將\"等待輸入運算數\"設為真. 使用者再輸入數字 3, 進入數字按鍵處理方法, 因\"等待輸入運算數\"為真, 因此刷新顯示幕, 重置\"等待輸入運算數\", 在顯示幕中列出 3. 使用者此時輸入 =, 左運算數即為暫存累加變數, 為 55, 運算子為 +, 顯示幕上的 3 則為目前的右運算數, = 按鍵處理方法, 進入暫存累加變數 55 再加上運算數 3 的運算, 得到 58, 將數值列在顯示幕, 所有變數重置恢復原始值, 即\"等待輸入運算數\"為真, 暫存變數歸零. 上述計算機的行為, 可以利用有限狀態機器的方式進行模擬, 普通計算機有多少狀態? 當計算機從某一狀態轉進另一狀態時, 應該如何表示出計算機該有的行為? Github 協同展示倉儲: https://github.com/scrum-1/scrum_pyqt5_calculator 參考資料 Calculator Walkthrough: Part 4 Finite State Machines and the State Design Pattern 電腦輔助設計實習監控程式 延續計算機程式課程所使用的 Python3 加上 PyQt5 語法, 可以開發用於監控虛擬或實體系統的視窗程式. 以下則為目前用於控制 V-rep 機電系統模擬的程式: run.py 的程式碼主要導入位於 ui 目錄下的 Dialog.py 程式模組, 並且利用其中的 Dialog 類別建立案例, 產生 win 物件, 然後再以 show() 方法展示對話框. import sys from PyQt5 import QtWidgets from ui import Dialog app = QtWidgets.QApplication(sys.argv) win = Dialog.Dialog() win.show() sys.exit(app.exec()) PyQt5 控制程式 此外, 對話框中有三個 press button 按鈕, 以及一個 line edit 用來顯示完成軌道運行的鋼球個數. 與 Dialog.ui 對應的對話框邏輯程式名稱定為 Dialog.py, 內容如下: # -*- coding: utf-8 -*- \"\"\" Module implementing Dialog. \"\"\" # 從 PyQt5.QtWidgets 模組中導入 QDialog 類別 from PyQt5.QtWidgets import QDialog # 從同目錄中的 Ui_Dialog.py 模組導入 Ui_Dialog 類別 from .Ui_Dialog import Ui_Dialog # for V-rep # 從 remoteapi 目錄中導入 vrep.py 模組 from remoteapi import vrep import sys # 導入 threading, 用於建立執行緒 import threading import time class Dialog(QDialog, Ui_Dialog): \"\"\" Class documentation goes here. \"\"\" def __init__(self, parent=None): \"\"\" Constructor @param parent reference to the parent widget @type QWidget \"\"\" super(Dialog, self).__init__(parent) self.setupUi(self) # count, clientID, very_beginning, make 與 pill2kill 都是類別的成員屬性 self.count = 0 self.clientID = 0 self.very_beginning = True # 以 self.start_thread 為標的, 建立執行緒 self.make = threading.Thread(target=self.start_thread) self.pill2kill = threading.Event() # 從 Ui_Dialog 繼承而來的成員物件 self.display.setText(str(self.count)) # 為三個 press button 建立 signals 與 slots 對應 self.start.clicked.connect(self.start_motor) self.stop.clicked.connect(self.stop_motor) self.pause.clicked.connect(self.pause_motor) # 啟動轉動馬達的 slot, 也就是按下 self.start 按鈕後將執行的對應方法 def start_motor(self): # 利用執行緒執行 start, 執行緒只能啟動一次的判斷成員變數 self.very_beginning if self.very_beginning: # 啟動執行緒 self.make.start() self.very_beginning = False else: # 暫停後, 重啟執行緒 self.pill2kill.set #啟動模擬 vrep.simxStartSimulation(self.clientID, vrep.simx_opmode_oneshot) # 停止馬達執行方法 def stop_motor(self): # 按下停止鍵, 將會停止模擬, 重新回到原始設定畫面 vrep.simxStopSimulation(self.clientID, vrep.simx_opmode_oneshot_wait) # 暫停執行處理方法 def pause_motor(self): # 暫停執行緒, 暫停模擬 #time.sleep(2) # 暫停執行緒 self.pill2kill.clear() # 暫停模擬 vrep.simxPauseSimulation(self.clientID, vrep.simx_opmode_oneshot_wait) # 啟動執行緒的對應方法 def start_thread(self): # child threaded script: # 內建使用 port 19997 若要加入其他 port, 在 serve 端程式納入 #simExtRemoteApiStart(19999) vrep.simxFinish(-1) self.clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5) #啟動模擬 vrep.simxStartSimulation(self.clientID, vrep.simx_opmode_oneshot) if self.clientID!= -1: print(\"Connected to remote server\") else: print('Connection not successful') sys.exit('Could not connect') errorCode1, Revolute_joint_handle = vrep.simxGetObjectHandle(self.clientID,'Revolute_joint',vrep.simx_opmode_oneshot_wait) errorCode2, sensorHandle = vrep.simxGetObjectHandle(self.clientID,'Finish',vrep.simx_opmode_oneshot_wait) if errorCode1 == -1: print('Can not find left or right motor') sys.exit() while vrep.simxGetConnectionId(self.clientID) != -1: (errorCode3, detectionState1, detectedPoint1, detectedObjectHandle1, detectedSurfaceNormalVector1) = vrep.simxReadProximitySensor(self.clientID, sensorHandle, vrep.simx_opmode_streaming) if errorCode3 == vrep.simx_return_ok: if detectionState1: self.count += 1 print(\"通過球總數:\", self.count) # 將 self.count 顯示在 display self.display.setText(str(self.count)) # 設定馬達的轉速 vrep.simxSetJointTargetVelocity(self.clientID, Revolute_joint_handle, 0.5, vrep.simx_opmode_oneshot_wait) #終止模擬 vrep.simxStopSimulation(self.clientID, vrep.simx_opmode_oneshot_wait) 根據上述程式碼所完成的測試影片: 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第十一週第二部分, 在期末機電資協同專案範例中, 加入感測器與控制用視窗程式示範 from 國立虎尾科技大學機械設計工程系 on Vimeo .","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-event-driven-programming-design.html"},{"title":"Pelican 與 Pandoc MD 導引","text":"Pelican 是一套靜態網誌產生程式, 使用者可以從 https://github.com/getpelican/pelican 下載, 操作手冊位於 Pelican Document . Markdown 中的連結 假如將上述超文件的 Markdown 列出, 就可以看出其中有三種引用全球資訊網 URL 連結的不同格式寫法: [ Pelican ] 是一套靜態網誌產生程式 , 使用者可以從 < https : //github.com/getpelican/pelican> 下載, 操作手冊位於 [Pelican Document](http://docs.getpelican.com/en/stable/). <!-- PELICAN_END_SUMMARY --> <!-- 以下為 Pandoc Markdown 連結中的引用連結格式 --> [ Pelican ] : https : //github.com/getpelican/pelican 從 https://pandoc.org/MANUAL.html#reference-links 可以了解, 在 URL 網址前後加上尖括號 (angle brackets) 可以直接引用該連結, 轉成 html 之後, 就是一個以網址為連結文字的 anchor 標註, 假如在文章中需要透過關鍵字, 大量引用某一個網址，則可以使用 Reference Links, 也就是用中括號 (brackets) 圈住所要連結的按鈕文字後, 在文章任何地方, 以中括號標示引用的關鍵字, 然後加上冒號 (colon) 再接上點按該引用關鍵字後, 所要連結的網址. 也就是上段文句中, 一開頭引用 Pelican Github 倉儲的用法. 假如希望在文章中直接以按鈕關鍵字連接網站, 則可以使用 Inline Links, 也就是利用中括號 (brackets) 圈住所要連結的按鈕文字後, 直接 (中括號與小括號間不可以有空白) 加上以小括號 (parentheses) 圈起的網址. 與這些文字寫作相關的符號英文名稱, 可以參考 http://www.thepunctuationguide.com . 此外, 我們在 Markdown 格式文章中, 選擇採用 html 的註解格式, 當內容被轉換為 html 時, 仍會保留, 但是轉成 LaTeX 格式後, 這些原始內容中的註解將不會出現. 操作影片的引用 在超文件中引用操作影片, 使用者可以從嵌入的小視窗點擊後, 直接在瀏覽器上觀看影片. 但是若該影片嵌入經過 Pandoc 將 Markdown 格式內容, 先轉為 LaTeX 之後, 再輸出為 PDF 格式, 比較好的做法, 應該是呈現能夠代表該影片的圖片, 然後再提供連結到該影片的 URL. Youtube 提供了直接透過影片連結, 取得代表圖片的方法, 例如: 影片連結為 https://www.youtube.com/watch?v=xCa6YX8vJOI 的代表圖片為: 從影片連結取得對應圖片的說明如下: 從 Vimeo 影片連結取相關圖片: https://coderwall.com/p/fdrdmg/get-a-thumbnail-from-a-vimeo-video 從 Youtube 影片連結取相關圖片: https://coderwall.com/p/nihgwq/get-a-thumbnail-from-a-youtube-video 以下則是利用 JQuery 與 Vimeo 的 API, 利用影片 id 擷取相關圖片的方法, 所使用的影片為 https://vimeo.com/243129278 : Javascript 程式碼與 img 標註如下: function vimeoLoadingThumb(id){ var url = \"https://vimeo.com/api/v2/video/\" + id + \".json?callback=showThumb\"; var id_img = \"#vimeo-\" + id; var script = document.createElement( 'script' ); script.type = 'text/javascript'; script.src = url; $(id_img).before(script); } function showThumb(data){ var id_img = \"#vimeo-\" + data[0].id; $(id_img).attr('src',data[0].thumbnail_large); } $(function() { vimeoLoadingThumb(243129278); }); 圖片引用 在本網誌倉儲, 圖片目錄位於 data/images, 使用者可以利用: ![圖片 caption](./../data/images/procedure_vs_gui_flow.png) 直接引用這張圖: 數學方程式 在 Pelican 網誌中的 Markdown 可以輸入 LaTeX 格式的數學方程式, 例如: 下列數學式原始碼, 可以轉為動態 gif 圖檔. $$Fit_{min} = \\sum_{i=0}&#94;{n}\\sqrt{(O_{x,i}-N_{x,i})&#94;2+(O_{y,i}-N_{y,i})&#94;2}$$ 轉換完成的數學方程式: $$Fit_{min} = \\sum_{i=0}&#94;{n}\\sqrt{(O_{x,i}-N_{x,i})&#94;2+(O_{y,i}-N_{y,i})&#94;2}$$ Pelican 文章中的 status 在 Pelican 中的 Markdown 格式, 支援 Status: draft 與 Status: published 等兩種 status, 前者代表尚未完成的草稿, 而後者的狀態為內建的\"已經出版\". Git 與 Github 2017 Fall 的課程中, 首先導入的軟體組態管理系統為 Fossil SCM , 其特色是檔案小但是功能齊全, 可方便在區域或廣域網路上建立個人或團隊的專案倉儲, 但是若要擴大倉儲資料的應用性, 就必須使用 Git 與 Github , 至於 Bitbucket 與 Gitlab 或其他類似的服務, 則可用來做為主要倉儲的備份. Github 的初步使用, 可以參考 https://guides.github.com/activities/hello-world/ , 較完整的 Git 使用說明, 請參考 https://git-scm.com/book/zh-tw/v2 . 課程實習 自第十二週起, 每一位學員必須利用各自學校配發的 Gmail 申請 Github 帳號, 計算機程式將以小組為單位, 練習利用分組 Github 倉儲, 協同開發 Python3 + PyQt5 程式, 並準備各組的簡報、網頁與 PDF 格式的期末報告. 電腦輔助設計實習課程學員, 尚未申請 Github 者, 也必須自行申請, 之後必須設法在小組倉儲中準備各組的簡報網頁與 PDF 格式的期末報告.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-pelican-and-pandoc-markdown-format.html"},{"title":"reStructuredText 格式網誌","text":"Pelican 靜態網誌的文章編寫, 可以採 Markdown 格式, 存為 .md 檔案, 也可以採 reStructuredText 格式, 存為 .rst Markdown 格式的資料, 主要應用於網頁, 而 reStructuredText 格式的資料, 則設計用來編寫科技文章. Sphinx Sphinx 是 Python 專用的說明文件產生器, 可以將 reStructuredText 格式的內容轉為一般 HTML、Windows HTML Help、LaTeX、ePub、Texinfo、manual pages 與 plain text 格式內容. Sphinx 的功能: Output formats: HTML (including Windows HTML Help), LaTeX (for printable PDF versions), ePub, Texinfo, manual pages, plain text Extensive cross-references: semantic markup and automatic links for functions, classes, citations, glossary terms and similar pieces of information Hierarchical structure: easy definition of a document tree, with automatic links to siblings, parents and children Automatic indices: general index as well as a language-specific module indices Code handling: automatic highlighting using the Pygments highlighter Extensions: automatic testing of code snippets, inclusion of docstrings from Python modules (API docs), and more Contributed extensions: more than 50 extensions contributed by users in a second repository; most of them installable from PyPI print ( \"Pelican is a static site generator.\" ) 連結資料的引用, 可以在設定內容之前, 也可以放在設定內容之後, 例如: reStructuredText 連結的引用設在定義連結之後, 而上一段同一關鍵字的連結引用, 則放在連結設定定義之前 換言之, 整個文章會用到的連結資料, 可以統一整理在 .rst 文章任何位置後, 再用於編輯文章時使用. Pandoc 手冊 PandocUserGuide 是 Pandoc 的使用者手冊 以下為 bullet list 用法: This is the first bullet list item. The blank line above the first list item is required; blank lines between list items (such as below this paragraph) are optional. This is the first paragraph in the second item in the list. This is the second paragraph in the second item in the list. The blank line above this paragraph is required. The left edge of this paragraph lines up with the paragraph above, both indented relative to the bullet. This is a sublist. The bullet lines up with the left edge of the text blocks above. A sublist is a new list so requires a blank line above and below. This is the third item of the main list. This paragraph is not part of the list. 文章 Status Pelican 靜態網誌中所準備的文章, 目前放在 content 目錄中, 可以使用 .md 或者 .rst 的格式, 假如文章尚未完成, 使用者可以在文章標題欄位中, 加入一個 status 欄位, 若為 draft, 表示文章為草稿, 轉檔時不會轉為 html 格式, 若 status 為內定的 published, 則表示文章已經完成, 可以透過 Leo Editor 的轉檔按鈕轉入 Blog 內容. Pelican Plugins 目前所使用的 Pelican 網誌, 設定時納入 summary 的延伸功能, 使用者可以在文章中加入內容為 PELICAN_END_SUMMARY 的註解, 在 Markdown 中可以使用 html 註解格式, 而在 rst 中, 則可以在前面加入兩個逗號, 表示該分隔註解與內文的標註為註解, Pelican 網誌系統轉檔時, 只會啟用分隔功能, 不會納入該行資料. Summary Plugin","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-restrcturedtext-format-blog.html"},{"title":"如何編寫期末報告?","text":"報告 (Report) 是一種經由觀察 (Observation) 與查問 (Inquiry) 手段, 針對相關事件 (Event) 所完成的詳細說明 (Statement describing in detail). 報告的基本要素 課程中要求學員繳交期末報告之目的, 在評定學習成效 (Level of learning achievement), 並藉以給分 (Grading). 期末報告的基本內容: 標題頁 - 含報告標題、作者、日期與所屬單位 目錄 - 列出全文章節與所屬頁面連結 摘要 - 解釋報告編寫動機、報告重點、結論、建議與關鍵字 前言 - 簡要描述全文意旨與背景, 說明報告目標與報告內容組成架構 內文 - 依照章節標題, 詳細說明報告內容, 包括方法、操作步驟與所得結果的詳細說明 結論 - 條列所獲致的重要成果, 與摘要及導言中的目標互相呼應 討論與建議 - 說明後續值得進行的方向、方法與可能遭遇問題的討論 參考 - 詳列所引用的參考內容 附錄 - 附加值得參考的詳細內容 這裡所要求的期末報告, 必須繳交 .docx, .tex, .md 等原始檔案外, 還必須轉為 .pdf 格式繳交 . 其中 pdf 檔案的第一頁就是期末報告標題頁, 必須註明報告標題, 作者, 日期與所屬單位. 緊接著標題頁之後, 必須預留一頁空白, 然後接報告目錄. 目錄必須包含各章節標題以及所屬頁次. 報告目錄之後, 再預留一頁空白之後, 接報告摘要, 主要解釋報告編寫動機、報告重點、結論、建議與關鍵字. 摘要之後直接開始從前言 (Introduction) 編寫各章節內容, 其中必須善用文字之外, 還要利用 2D 圖表, 並將相關操作過程拍攝為 mp4 影片上傳到 Vimeo 與 Youtube, 並在內文中提供連結. 目前的計算機程式除了簡單的加減乘除運算之外, 並沒有其他數學理論內容, 但是電腦輔助設計實習課程中, 有關機構分析, 干涉約束點的運算都可以藉數學分析進行設計表達, 且簡單的機構合成部分除了可以使用圖解法外, 也可以利用解聯立方程式或合成演算法求解, 各學員可以在報告內文中加以陳述各鋼球循環運動系統設計中, 所運用的數學理論分析. 最後, 期末報告的附錄, 可以放入內文中所提到使用的程式原始碼或其他相關摘錄的說明手冊等資料. 參考資料 cdict The key elements of a report How to Write a Report?","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-how-to-write-a-report.html"},{"title":"何謂電腦輔助設計?","text":"電腦輔助設計的英文為 Computer Aided Design, 大意是運用電腦的功能與特性, 協助使用者完成設計. 所謂電腦輔助設計 電腦的原始設計目的主要用於運算 ( Computing ), 隨著數位顯像與多點觸控技術的提升, 網路應用的普及, 以及各類模擬分析與設計軟體套件的開發, 電腦已然在虛實系統 ( Cyber-physical System ) 整合工程領域, 成為不可或缺的工具. 設計之所以是一種表達, 從兩個中文字的左邊言部就能窺其創字之原意, 設字的右邊, 從役字的右半邊, 表示其施行是指使他人為之, 因此設後所得之結果, 可讓人有所依循而為. 至於計字的右半邊為十, 表示數量之大, 引申其表達乃經過多方且多次的討論與思量後才得獲致之結果. 因此設計不僅是一種表達, 而且是歷經詳細思慮考量後的具體規劃表達, 必須具體到可以讓人依循, 按照細部規劃施行後, 得到預期結果的表達. 所謂輔助中的輔字, 原意為車輪兩旁夾車之物, 引申為扶持相助但必要時可解脫之物, 因此輔助乃必要時可提供協助之意. 綜合上述的說明, 所謂的電腦輔助設計, 就是在必要情況下, 透過電腦的協助, 讓使用者完成設計之意. 換言之, 所謂的電腦輔助機械設計, 就是在必要情況下, 透過電腦的協助, 讓使用者完成機械設計之意. 而機字意指互動元件間之精巧配置, 而械字則指可展現特定功能, 用於解決所面臨問題的器物, 因此所謂的電腦輔助機械設計, 就是在必要情況下, 透過電腦的協助, 讓使用者得以歷經詳細思慮考量, 完成互動元件間之精巧配置, 使其展現特定功能之具體規劃表達之謂. 至於現今所謂機械設計中的互動元件, 泛指固體、流體與軟體元件. 而電腦輔助設計或電腦輔助機械設計的結果, 就是運用口語、文字、2D、3D、數學與實體等表達方法交互運用下所完成的可交付內容 ( Deliverables ). 輔助的原意 輔字的原意為扶持相助但必要時可解脫之物, 表示電腦輔助設計過程中的電腦只是相持之物, 而非唯一主體, 操作電腦的個體或團隊才是主體, 當拿掉電腦軟硬體, 沒有電腦網路, 缺少多點觸控螢幕, 失去投影幕後, 使用者仍然必須能夠完成設計, 交付內容, 這才是輔助的原意. 換言之, 電腦輔助設計過程中, 並非一定得要在特定的軟硬體與網路條件下, 才能完成工作, 而必須通過各種實際情況的考驗, 在堪用工具, 甚至自行打造工具的環境中完成設計. 設計的可交付內容 早年專利的審查與可交付內容, 由於時代背景的限制, 只允許使用文字、2D 與數學表達呈現, 即便所謂的研發紀錄內容, 也止於這三種靜態且難以全時履歷內容加以呈現. 自 2005 Git 分散式版次管理系統的出現, 一直到 2015 年 Onshape 全雲端具版次管理功能的電腦輔助機械設計軟體套件的發展, 任何設計的可交付內容, 已然能夠即時多樣呈現之外, 加上各式結合口語、3D 動態影音甚或逼真高效的虛實整合的表達內容, 已經顛覆當年訂定專利靜態設計可交付內容的樣貌. 人才是設計的主體 1998 年 Google 成立, 2004 年出現 Facebook , 2008 年 Github 正式上線, 2015 年全雲端 Onshape 電腦輔助機械設計可以在手機與平板上進行協同設計, 2017 年 AI 人工智慧程式的功能展現, 已經遠遠 超越 單一人類所能發揮的能力, 過去 20 年在各式電腦輔助工具與環境不斷推陳出新的情況下, 千萬不要忘記, 設計團隊的主體是人, 而且設計交付內容的最終產物使用者, 其主體也是人. 結論就是, 上述這些功能強大的工具, 都是由人所組成的團隊所打造建置的, 電腦輔助設計過程中的任何一位成員, 必須真確了解電腦的功能, 輔助的原意, 以及設計的最後宗旨, 方能達到役物而不役於物的最高境界.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-cadp-what-is-computer-aided-design.html"},{"title":"CADP 鋼球運動系統電腦輔助設計","text":"2017 Fall CADP 課程的機電資整合實習題目為: 可重複循環運作的鋼球運動系統, 其中包括 機械領域 的: 機構運球系統與模組化軌道設計, 電子領域 的: Arduino 伺服馬達控制設計, 以及 資訊領域 的: PyQt5 監控程式系統設計等三個部分. 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第十週第一部分, 說明何謂電腦輔助設計? 以及如何進行機電資實習專案. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第十週第二部分, 說明如何利用 AutoDesk TinkerCAD 中的 Circuits 模擬 Arduino 伺服馬達控制. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第十週第三部分, 從 TinkerCAD 中下載 Marble Machine 軌道範例, 轉進 V-rep 模擬. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第十週第四部分, 從 Thingiverse 中下載 Marble Machine 軌道範例, 轉進 V-rep 模擬. from 國立虎尾科技大學機械設計工程系 on Vimeo . 機電資整合鋼球運動系統設計要求 其中, 連桿機構零組件 可以採用系上既有的 Solvespace 、 Onshape 、 Dassault Solidworks 、 AutoDesk Inventor 、 AutoDesk A360 或 PTC Creo 繪製, 機構與鋼球運動模擬 可以採用 V-rep 或 Blender 進行, 控制 V-rep 模擬系統的外部程式套件, 可以採用 Python3 remote API 架構完成, 電子系統 可以採用 AutoDesk TinkerCAD 模擬, 用來記錄鋼球通過關鍵點次數, 以及鋼球運動總距離及總爬升高度的 資訊系統 , 則可以採用 Python3 以及 PyQt5 建置, 而主要機構零組件則可以採系上既有的 3D 印表機組列印. 各組所完成的\"機電資整合鋼球運動系統\", 必須包含一個主要的鋼球運送機構模組 (以下稱為主模組), 並且能夠納入各學員所完成的軌道機構模組 (以下稱為軌道模組), 進行循環運動, 且 整體系統的尺寸必須能夠放入郵局 Box2 紙箱 中(規格: 23×18×19(cm) . 當各組開始啟動\"機電資整合鋼球運動系統\"專題製作時, 各學員必須將所有細節紀錄在 二甲 與 二乙 所分配到的 Fossil SCM 伺服器主機中, 且各學員在近端隨身碟必須自行保全所有與專題相關的資料, 專題完成後, 再將各學員的 Fossil SCM 倉儲同步到 Github 倉儲. 各班依照座位, 前後三人共六人為一小組, 必須完成一套主模組設計, 各學員則分別提供一組軌道模組配合, 進行循環運動模擬. 第十三週起則每三小組合併成一大組, 根據學員投票決定 實作一組主模組, 各學員則必須實作一組軌道系統與主模組配合運作 . 最後各大組以協同方式完成電腦輔助設計實習報告, 各學員則根據所參與內容, 完成個人期末報告, 分別以 Reveal.js 網際簡報、Pelican 網誌、Vimeo 與 Youtube 影片呈現. 機構運球系統與模組化軌道設計 平面四連桿機構合成 利用平面四連桿, 指定浮動桿從模組軌道最低點位置 (10.50 mm), 將球運送到模組軌道最高點位置 (135.59 mm), 額外再指定中間通過的一組浮動桿位置, 以三個位置為設計目標, 透過機構合成計算出兩個機構固定點的位置, 利用模擬方法驗證. 平面四連桿浮動桿通過三個特定點圖示: 上述機構合成題目可以採圖解法求出四連桿兩個固定點的位置, 以及各連桿的尺寸, 也可以利用下列 Python3 程式, 以 Symbolic 及 Numerical 運算方法, 計算出符合上述, 浮動桿通過三個選定位置的固定點座標: from sympy.geometry import * from sympy import N # N(expr, <args>) 等於 sympify(expr).evalf(<args>) P1 = Point(-127.11, 37.29) P2 = Point(-89.42, 50.69) P3 = Point(-113.61, 73.77) P4 = Point(-74.73, 64.37) P5 = Point(-89.19, 88.52) P6 = Point(-56.84, 64.99) S1 = Segment(P1, P2) S2 = Segment(P3, P4) S3 = Segment(P5, P6) #print(N(S1.length)) # 求 numerical value #print(N(S2.length)) #print(N(S3.length)) #print(S1.slope) #print(S1.intersection(S2)) #print(angle_between(S1, S2)) # 求 L13, L35 通過兩線中點垂直線的交點, 即為固定點 1 L13 = Line(P1, P3) L35 = Line(P3, P5) S13 = Segment(P1, P3) S35 = Segment(P3, P5) midS13 = S13.midpoint midS35 = S35.midpoint perL13 = L13.perpendicular_line(midS13) # perpendicular line to L1 perL35 = L35.perpendicular_line(midS35) # perpendicular line to L2 #print(L2.arbitrary_point() ) # parametric equation of L2 #Point(4*t + 2, -3*t - 1) #print(L2.equation() ) # algebraic equation of L2 #3*x + 4*y - 2 #print(L2.distance(P4)) # distance from P4 to L2 print(N(perL13.intersection(perL35)[0], 3)) # 求 L24, L46 通過兩線中點垂直線的交點, 即為固定點 2 L24 = Line(P2, P4) L46 = Line(P4, P6) S24 = Segment(P2, P4) S46 = Segment(P4, P6) midS24 = S24.midpoint midS46 = S46.midpoint perL24 = L24.perpendicular_line(midS24) # perpendicular line to L1 perL46 = L46.perpendicular_line(midS46) # perpendicular line to L2 #print(L2.arbitrary_point() ) # parametric equation of L2 #Point(4*t + 2, -3*t - 1) #print(L2.equation() ) # algebraic equation of L2 #3*x + 4*y - 2 #print(L2.distance(P4)) # distance from P4 to L2 print(N(perL24.intersection(perL46)[0], 3)) 利用上述 Python3 程式計算出兩個固定點的座標位置分別位於 (-76.0, 39.1) 以及 (-64.9, 39.1): 合成結果驗證: 參考影片: 平面六連桿機構合成 平面八連桿機構合成 模組化軌道設計 平面機構合成參考論文 (只有在系上電腦可以下載) 上述下載包括: The synthesis of six-bar linkages as constrained planar 3R chains (2008) Kinematic analysis and synthesis of an adjustable six-bar linkage (2009) A GA–DE hybrid evolutionary algorithm for path synthesis of four-bar linkage (2010) Coupler-curve synthesis of four-bar linkages via a novel formulation (2015) Synthesis of eight-bar linkages by constraining a 6R loop (2016) Design of Stephenson linkages that guide a point along a specified trajectory (2016) Dimensional synthesis of six-bar Stephenson II linkage for fifteen precision points path generation (2016) Kinematic synthesis of Stephenson III six-bar function generators (2016) Optimal design of toggle-linkage mechanism for clamping applications (2017) Optimal synthesis of four-bar path generator linkages using circular proximity function (2017) Arduino 伺服馬達控制設計 伺服馬達控制模擬 為了在實體 Arduino Uno 控制板連線操作之前, 可以利用網際 Auduino 控制板與電子元件系統進行模擬, 請各學員至 https://www.tinkercad.com 登記帳號, 登入後選擇左上角的 TinkerCAD 標誌連結後, 選擇 Circuits 進入電路設計與模擬, 操作畫面如下圖所示: 接著選擇 Arudino Uno 控制板與 Servo Motor, 然後接上電源與地線, 並將控制訊號接到 Auduino Uno 控制板的 PWM pin 9, 利用 Code Editor 納入下列 Arduino 程式, 再利用 upload and run 將程式編譯後上傳到虛擬的 Arduino Uno 控制板上執行, 就可以模擬 Servo Motor 持續左右各旋轉 180 度. 操作畫面如下圖所示: 實體 Arduino Servo Motor Control 完成上述以 TinkerCAD 模擬伺服馬達的接線與程式執行之後, 接著操作實體 Arduino 控制板與 Servo Motor 的控制, 首先利用電腦驅動 Arduino 控制板, 然後再利用板子上的脈衝寬度調變 (PWM, Pulse Width Modulation) 訊號控制伺服馬達, 之後再利用傳動機構與資訊控制介面, 製作所需的機電資整合系統. 電子電機系統除了可以方便感測各種物理化學量外, 還能夠快速傳遞感測與命令訊號, 而機械系統則透過機構元件的組合, 扮演傳遞功率致動或抵抗外力撞擊與疲勞破壞的角色, 至於資訊系統則用來整合各種資訊, 用更友善的人機介面, 讓使用者更有效能地運用機電資系統產品. https://service.mde.tw/public/arduino-1.8.4-windows.zip 下載 控制台 - 硬體與音效 - 裝置管理員 利用解開的 arduino driver 程式驅動 Arduino Uno 控制板, 並取得 COM 對應號碼, 例如: COM7, 之後的 Arduino 編譯後可以透過此 COM 埠號將程式上傳到控制板上執行. MG996R 伺服馬達 棕色線 GND 紅色線 V+5V 橘色線 PWM 控制程式: #include <Servo.h> Servo myservo; // 建立一個 servo 物件，最多可建立 12個 servo int pos = 0; // 設定 Servo 位置的變數 void setup() { myservo.attach(9); // 將 servo 物件連接到 pin 9 } void loop() { // 正轉 180度 for (pos = 0; pos <= 180; pos += 1) // 從 0 度旋轉到 180 度，每次 1 度 { myservo.write(pos); // 告訴 servo 走到 'pos' 的位置 delay(15); // 等待 15ms 讓 servo 走到指定位置 } // 反轉 180度 for (pos = 180; pos >= 0; pos -= 1) // 從 180 度旋轉到 0 度，每次 1 度 { myservo.write(pos); // 告訴 servo 走到 'pos' 的位置 delay(15); // 等待 15ms 讓 servo 走到指定位置 } } PyQt5 監控程式系統設計 視窗監控程式設計採用 Python3 與 PyQt5 , 在 Eric6 整合開發環境中進行開發, 主要透過 V-rep 的 Python Remote API 技術進行: 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第十一週第二部分, 在期末機電資協同專案範例中, 加入感測器與控制用視窗程式示範 from 國立虎尾科技大學機械設計工程系 on Vimeo . 機構概念設計到細部設計 Onshape 零組件檔案 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 第十二週延伸 Solvespace 中的機構合成概念設計, 在 Onshape 中完成細部零組件設計繪圖. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 第十二週利用 Solvespace 所建立的半圓形軌道, 轉入 V-rep 中進行機構導球測試. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二乙第十二週第一部分, 說明各組員與分組的期末報告章節要求, 以及如何執行提球機構零組件設計與模擬. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二乙第十二週第二部分, 說明如何將 Onshape 所完成的雙曲柄滑塊機構轉入 V-rep 進行動態模擬. from 國立虎尾科技大學機械設計工程系 on Vimeo .","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-cadp-fourbar-three-position-synthesis.html"},{"title":"CADP PTC Creo4 電腦輔助設計套件","text":"學習 PTC Creo4 的最佳初級參考資料為: Creo Tutorial 與 Creo Parametric Primer . 各學員可以在系上網路主幹上, 直接 下載可攜 PTC Creo4 套件 (只有系上電腦可以下載), 放入 USB 3.0 規格以上的隨身碟, 此套件將透過網路連線取得合法認證後啟動, 此一版本的有效日期: 14-sep-2018, 提供 Creo Parametric 4.0, Creo Direct 4.0 與 Creo Simulate 4.0 教育版功能. 除了系上每年更新的 PTC Creo 電腦輔助設計室教育版本外, 學員也可以至 申請下載免費的 Creo 學生版 . 目前一般機械設計業界使用的電腦輔助設計 3D 參數套件, 大致有中端級的 Dassault Solidworks , AutoDesk Inventor 與 Siemens Solid Edge , 以及高端級的 PTC Creo , Siemens NX , 與 Dassault Catia . 其中使用最多的為 Dassault Solidworks , 普遍認為最容易上手, 整體繪圖流程順暢, 但在多零組件與曲面設計上的表現不如 PTC Creo 或其他高端 MCAD 套件. 由於上述各種單機版本的電腦輔助設計套件, 其安裝與版次的管理較為繁雜, 且成員間的協同設計必須仰賴 PLM 系統, 因此於 2014 - 2015 年間興起的雲端 MCAD 套件 AutoDesk A360 與 Onshape , 已經逐步嶄露頭角, 可以在一般電腦的瀏覽器上登入使用, 也可以使用手機或平板電腦上的專用 Apps 登入帳號後, 進行協同設計.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-creo4-1.html"},{"title":"CP PyQt5 視窗程式 (二)","text":"當使用者透過 Eric6 與 Qt Designer 完成基本計算機表單的視窗對話框後, 分別使用了 Qt Designer 中的 Grid Layout、Press Button 與 Line Edit 等 Widgets. 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第十週第二部分, 說明如何利用 Eric6 建立簡單的計算機程式, 包含利用 Qt Designer 建立對話框, 並建立透過主程式引用執行. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第十週第三部分, 說明如何開始利用 Eric6 與 Qt Designer, 建立計算機程式所需的對話框以及程式邏輯. from 國立虎尾科技大學機械設計工程系 on Vimeo . 接下來則必須配合 Dialog.ui, 在 Eric6 的表單頁面, 在 Dialog.ui 位置以滑鼠右鍵, 指定 Generate Dialog Code, 操作畫面如下: 接著點擊 New 後在 ui 目錄下, 建立 Dialog.py 檔案, 操作畫面如下: 之後與 Dialog.ui 編譯後的 Ui_Dialog.py 程式碼對應的 Dialog.py (可以自選 Generate Dialog Code 的檔案名稱 ,這裡選擇存為 Dialog.py), 將存放與對話表單相應的程式邏輯. 意即, 當用戶使用 Qt Designer 設計對話視窗表單後, 整體程式開發流程將分為 1) 以滑鼠產生對話框圖形介面與 2) 配合手動建立邏輯檔案等兩個流程, 由 Qt Designer 自動轉為 Ui_Dialog.py 程式碼的基本圖形介面建立流程, 使用者將不會手動編輯改變此一檔案的內容, 且主程式的模組導入則以手動建立的邏輯程式檔案為主. 例如: 上述位於 ui 目錄中的 Dialog.ui 編譯後, 得到 Ui_Dialog.py, 而與 Dialog.ui 對應的 Generate Dialog Code 所產生的 Dialog.py 檔案, 與主程式檔案 run.py 如下列所示: run.py # 導入 sys 模組, 主要用於 sys.argv 成員變數 import sys # 從 PQt5 模組導入 QtWidgets 模組類別 from PyQt5 import QtWidgets # 從 ui 目錄導入 Dialog.py, Python 程式檔案本身就是一個模組, 且文件名就是模組名 from ui import Dialog # 每一個 Python 程式都可以直接被執行, 或者被導入其他程式中, 當成導入模組執行 # 假如程式檔案直接被執行時, 全域變數 __name__ 就會等於 \"__main__\" 字串 # 因此, 以下的判斷式的意思是, 若本檔案直接被執行時, 就會執行以下內縮程式區段 if __name__ == \"__main__\": # 利用 QtWidgets.QApplication 類別建立案例物件, 且以 sys.argv 作為輸入 app = QtWidgets.QApplication(sys.argv) # 利用所導入的 Dialog 模組中的 Dialog 類別建立物件案例, 對應的變數名稱設為 win win = Dialog.Dialog() # 執行 win 物件中的 show() 方法, 因為所有 Qt5 部件內定為不顯示 win.show() # 執行 app 物件的 exec() 方法, 表示進入視窗事件重複迴圈, 等待使用者滑鼠輸入 # 將 app.exec() 當作 sys.exit() 執行輸入, 表示使用者可以透過視窗的 x 按鈕結束執行 sys.exit(app.exec()) Dialog.py 如下所示: # -*- coding: utf-8 -*- \"\"\" Module implementing Dialog. \"\"\" from PyQt5.QtCore import pyqtSlot from PyQt5.QtWidgets import QDialog from .Ui_Dialog import Ui_Dialog # Dialog 類別同時繼承 QDialog 與 Ui_Dialog 類別 class Dialog(QDialog, Ui_Dialog): \"\"\" Class documentation goes here. (若有類別相關說明文件內容, 放在此處) \"\"\" def __init__(self, parent=None): \"\"\" Constructor (類別建構子) @param parent reference to the parent widget @type QWidget \"\"\" # 利用 super 類別調用 parent 類別中的建構子 super(Dialog, self).__init__(parent) # 上一行在 Python3 可以寫為 super().__init__() # 利用 Ui_Dialog 類別中的 setupUi 方法, 以 self 視窗部件建立使用者介面 self.setupUi(self) # 以上程式碼由 Eric6 表單頁面中的滑鼠右鍵, Generate Dialog Code 指令產生 # 當多個 signal 同時指向同一個 slot 處理時, 採用 for loop num_button = [self.one, self.two, \\ self.three, self.four, self.five, self.six, self.seven, self.eight, self.nine, self.zero] # 用於產生加號與減號 signals 與 slots 用的數列 plus_minus = [self.plus, self.minus] # 用於產生乘號與除號 signals 與 slots 用的數列 multiply_divide = [self.multiply, self.divide] #self.one.clicked.connect(self.number) # 數字按鍵的 signals 與 slots 設定 for i in num_button: i.clicked.connect(self.number) # 加減鍵的 signals 與 slogts 設定 for i in plus_minus: i.clicked.connect(self.additiveOperatorClicked) # 等於按鍵的 signal 與 slot 設定 self.equal.clicked.connect(self.equalClicked) # 乘與除按建的 signals 與 slots 設定 for i in multiply_divide: i.clicked.connect(self.multiplicativeOperatorClicked) # 等待運算的加或減 self.pendingAdditiveOperator = '' # sumSoFar 儲存運算流程中所累計的數值 # 當使用者按下 = 後, sumSoFar 重新計算並將數字顯示在 display 區 # 當使用者按下 Clear All, sumSoFar 將重置回 0 self.sumSoFar = 0.0 # 起始時, 等待使用者輸入運算數值變數為真 self.waitingForOperand = True # sumInMemory 儲存計算機記憶體中的值, 配合 MS, M+, 或 MC 按鈕使用 self.sumInMemory = 0.0 # factorSoFar 暫存按下乘或除運算時的數值 self.factorSoFar = 0.0 # 等待運算的乘或除 self.pendingMultiplicativeOperator = '' def number(self): # sender() 為使用者點擊按鈕時送出的按鈕指標類別, 在此利用此按鍵類別建立案例 # 所建立的 clickedButton 即為當下使用者所按下的按鈕物件 clickedButton = self.sender() # text() 為利用按鈕物件的 text 方法取得該按鈕上所顯示的 text 字串 digitValue = int(clickedButton.text()) # when user clicks 0.0 if self.display.text() == '0' and digitValue == 0.0: return # if under digit input process, clear display for the very first beginning # waitingForOperand 為 True 已經點按運算數值按鈕 if self.waitingForOperand: # 清除 display self.display.clear() # 將判斷是否已經點按運算數值按鈕的判斷變數重新設為 False self.waitingForOperand = False # 利用 setText() 設定 LineEdit 元件顯示字串, 利用 text() 取出目前所顯示的字串, 同時也可利用 text() 擷取按鈕物件上顯示的字串 #self.display.setText(self.display.text() + self.sender().text()) self.display.setText(self.display.text() + str(digitValue)) def additiveOperatorClicked(self): # 確定按下加或減 clickedButton = self.sender() # 確定運算子, 為加或減 clickedOperator = clickedButton.text() # 點按運算子之前在 display 上的數字, 為運算數 operand = float(self.display.text()) # 納入乘與除之後的先乘除後加減運算邏輯, 且納入連續按下乘或除可累計運算 if self.pendingMultiplicativeOperator: if not self.calculate(operand, self.pendingMultiplicativeOperator): self.abortOperation() return self.display.setText(str(self.factorSoFar)) operand = self.factorSoFar self.factorSoFar = 0.0 self.pendingMultiplicativeOperator = '' # 假如有等待運算的加或減, 進入執行運算 # 且納入連續按下加或減時, 可以目前的運算數及運算子累計運算 if self.pendingAdditiveOperator: if not self.calculate(operand, self.pendingAdditiveOperator): self.abortOperation() return # 顯示目前的運算結果 self.display.setText(str(self.sumSoFar)) else: # 假如 self.pendingAdditiveOperator 為 False, 則將運算數與 self.fumSoFar 對應 self.sumSoFar = operand # 能夠重複按下加或減, 以目前的運算數值執行重複運算 self.pendingAdditiveOperator = clickedOperator # 進入等待另外一個運算數值的階段, 設為 True 才會清空 LineEdit self.waitingForOperand = True # 處理使用者按下乘或除按鍵時的 slot 方法 def multiplicativeOperatorClicked(self): clickedButton = self.sender() clickedOperator = clickedButton.text() # 將按鈕顯示的 text 轉為浮點數 operand = float(self.display.text()) # 若連續按下乘或除, 則以目前的運算數與運算子執行運算 if self.pendingMultiplicativeOperator: if not self.calculate(operand, self.pendingMultiplicativeOperator): self.abortOperation() return # 將目前乘或除的累計運算數顯示在 display 上 self.display.setText(str(self.factorSoFar)) else: self.factorSoFar = operand # 能夠重複按下乘或除, 以目前的運算數值執行重複運算 self.pendingMultiplicativeOperator = clickedOperator self.waitingForOperand = True def equalClicked(self): # 從 display 取的運算數值 operand = float(self.display.text()) # 先乘除的運算處理 if self.pendingMultiplicativeOperator: if not self.calculate(operand, self.pendingMultiplicativeOperator): self.abortOperation() return # factorSoFar 為乘或除運算所得之暫存數值 operand = self.factorSoFar self.factorSoFar = 0.0 self.pendingMultiplicativeOperator = '' # 若有等待加或減的運算子, 執行運算 if self.pendingAdditiveOperator: if not self.calculate(operand, self.pendingAdditiveOperator): self.abortOperation() return self.pendingAdditiveOperator = '' else: self.sumSoFar = operand self.display.setText(str(self.sumSoFar)) self.sumSoFar = 0.0 self.waitingForOperand = True # 右運算數與等待運算子當作輸入 def calculate(self, rightOperand, pendingOperator): # 進入計算流程時, 用目前輸入的運算數值與 self.sumSoFar 執行計算 if pendingOperator == \"+\": self.sumSoFar += rightOperand elif pendingOperator == \"-\": self.sumSoFar -= rightOperand elif pendingOperator == \"*\": self.factorSoFar *= rightOperand elif pendingOperator == \"/\": if rightOperand == 0.0: return False self.factorSoFar /= rightOperand return True 各變數的說明: sumInMemory contains the value stored in the calculator's memory (using MS, M+, or MC). sumSoFar stores the value accumulated so far. When the user clicks =, sumSoFar is recomputed and shown on the display. Clear All resets sumSoFar to zero. factorSoFar stores a temporary value when doing multiplications and divisions. pendingAdditiveOperator stores the last additive operator clicked by the user. pendingMultiplicativeOperator stores the last multiplicative operator clicked by the user. waitingForOperand is true when the calculator is expecting the user to start typing an operand. QApplication QtWidgets QDialog PyQt5 Signal and Slots Qt5 計算機範例說明 當按下數字按鍵 當使用者按下計算機的數字按紐時, 透過 self.one.clicked.connect(self.number), 數字按鍵將會送出 clicked() 信號, 透過 connect(self.number) 會觸發 number() 方法槽 (slot) 的執行. 這種信號與槽的使用為 PyQt5 簡化事件導向程式建構流程的特有方式. sender 在 Qt5 中為指標 當使用者按下計算機視窗程式中的按鍵時, 該 PyQt5 按鍵在 Qt5 程式庫中是利用 QObject::sender() 來傳送資料, 此函式將回傳 sender 作為 QObject 指標. 當 sender 為 Button 物件時, 此 sender 就是所按下的按鈕 QObject. 考慮使用者按下 0 鍵 處理數字按鍵的 slot 方法, 若目前 display 為 0, 而使用者又再次按下 0, display 不應該顯示 00, 而該只顯示 0. 另外, 若計算機視窗程式正處於等待使用者輸入新的運算數階段時, 在使用者按下新數值時, display 會清除先前顯示的數字, 只顯示新輸入的數值.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-pyqt5-2.html"},{"title":"CADP Onshape 零組件設計繪圖 (一)","text":"學習 Onshape 的最佳參考資料為: Videos Library , Learning Center 與 FeatureScript Doc . 其中, 我們將利用下列程式碼, 以各班每位學員指定兩個教學影片, 負責將內容摘要為中文, 並且將示範影片上傳至個人的 Vimeo 與 Youtube 帳號區. # 從 urllib 模組中導入 urlopen from urllib.request import urlopen # 從 bs4 模組中導入 BeautirulSoup from bs4 import BeautifulSoup # 從 random 模組導入 shuffle from random import shuffle # 將要取出影片連結的網站 url, 放入數列中, 取名為 sources sources = ['https://www.onshape.com/videos/topic/tech-tips', 'https://www.onshape.com/videos/topic/intro-to-cad', 'https://www.onshape.com/videos/topic/tutorials', 'https://www.onshape.com/videos/topic/essential-training', 'https://www.onshape.com/videos/topic/drawings'] #tech-tips (60) #intro-to-cad (26) #tutorials (14) #essential-training (6) #drawings (5) # 按照網頁中的影片數計算, 共有 111 部影片, 但分類中可能重複 #print(60+26+14+6+5) # 設 links 變數與空數列對應 links = [] # 利用 for 迴圈一一取出各網頁的 html 後, 進行解讀 # 只取出有 videos 與 https 連結的資料, 但避開 all 與 topic 類別連結 for url in sources: file = urlopen(url) # 因為 urlopen 出來的資料為二位元檔案, 若要讀出列印 # 必須要先 decode() 為字串 #print(file.read().decode()) # 使用 html 解讀各連結的網頁內容 soup = BeautifulSoup(file, 'html.parser') # 利用 Beautifulsoup 物件中的 find_all 方法尋找 anchor for link in soup.find_all('a', href=True): # 從各 anchor 資料篩選所需的影片連結 if ('videos' or 'https') in link['href']: if 'all' not in link['href']: if 'topic' not in link['href']: links.append(link['href']) # 為避免列出重複資料, 將數列轉為集合後, 再轉回數列 video_list = list(set(links)) shuffle(video_list) r_video_list = list(reversed(video_list)) # 逐一列出所取得的影片連結 #for i in range(len(video_list)): #print(i+1, video_list[i]) #讀取兩班學員學號名單 with open('2a_student_list.txt') as f: a_stud_list = f.read().splitlines() f.closed #print(a_stud_list ) # 每人取兩個影片, 一個從最前面取, 一個反向取連結 print(\"甲班 Onshape 影片分配名單:\") print() for i in range(len(a_stud_list)): print(\" * \"+str(a_stud_list[i])) print(\" * [\"+str(video_list[i])+\"]\") print(\" * [\"+str(r_video_list[i])+\"]\") with open('2b_student_list.txt') as f: b_stud_list = f.read().splitlines() f.closed print() print(\"乙班 Onshape 影片分配名單:\") print() for i in range(len(b_stud_list)): print(\" * \"+str(b_stud_list[i])) print(\" * [\"+str(video_list[i])+\"]\") print(\" * [\"+str(r_video_list[i])+\"]\") #print(b_stud_list ) 登入 Onshape 後, 首先必須利用左上方的 Document Menu-Workspace units 選擇繪圖單位, 選擇 length unit 與 mass unit.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-onshape-1.html"},{"title":"CP PyQt5 視窗程式 (一)","text":"2017 年 Fall 的計算機程式課程開始導入 PyQt5 視窗程式教學, 其中使用 Eric6 整合開發環境簡化初學者建立視窗表單. 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第十週第一部分, 說明如何客製化可攜程式系統, 直接以 start.bat 開啟 Leo Editor, 並開啟內定的專案檔 from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第十週第一部分, 說明如何客製化可攜程式系統, 直接以 start.bat 開啟 Leo Editor, 下載 Dia 與 Gimp 可攜程式, 用來編輯 2D 表達用的圖檔. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第十週第二部分, 說明如何利用 ShareX, Gimp 與 Dia 處理 2D 圖檔的內容標示. from 國立虎尾科技大學機械設計工程系 on Vimeo . 手動建立 PyQt5 視窗介面 最簡單的 PyQt5 程式直接利用 QtWidgets 中的 QWidget 呈現簡單的視窗, 然後利用 QApplication 建立應用程式後, 以應用程式的 exec() 方法進入事件迴圈. # 導入 sys 模組 import sys # 從 PyQt5 模組中導入 QtWidgets from PyQt5 import QtWidgets # 利用 QtWidgets.QApplication 類別建立應用程式案例物件, 名稱設為 app app = QtWidgets.QApplication(sys.argv) # 利用 QtWidgets.QWidget 類別建立視窗案例物件, 名稱設為 win win = QtWidgets.QWidget() # 利用視窗案例物件中的 show() 方法顯示 win 物件 win.show() # 執行 app 物件中的 exec() 方法, 以進入事件迴圈, 同時允許使用者透過視窗右上方的 x 按鈕, 關閉視窗. app.exit(app.exec()) 特別注意 PyQt5 模組中的 P 與 Q 為大寫, 而 QtWidgets 中的 Q 與 W 為大寫, QApplication 中的 Q 與 A 為大寫, 而 QWidget 中的 Q 與 W 為大寫. 另外, 利用 show() 方法將視窗元件顯示後, 其下的程式流程仍可繼續執行, 而對話框中所使用的 exec() 方法將會一直到使用者關閉對話框後, 才會將程式的控制權交回. QtWidgets 模組提供一組使用者介面元件 (User Interface elements), 用來建立傳統視窗桌面樣式的使用者操作介面. 事件導向的 PyQt5 程式基本控制流程為: 建立 QApplication 應用程式物件 建立視窗元件 顯示視窗元件 進入應用程式執行迴圈 等待使用者所觸發的事件 以 Eric6 建立 PyQt5 視窗介面 首先使用者必須利用可攜程式環境中的 fossil.exe 2.3 版 fossil clone https://mde1a1.kmol.info/pymcadp 倉儲, 操作指令為: 選定要 clone 倉儲存檔的目錄, 一般建議為 y:\\tmp\\fossil 目錄 更換目錄到倉儲存檔的目錄後, 執行 fossil clone https://mde1a1.kmol.info/pymcadp pymcadp.fossil 將 pymcadp.fossil 開啟在其目錄下的 wd\\pymcadp 目錄 更換目錄到 wd\\pymcadp 後, 執行 fossil open ./../../pymcadp.fossil 將遠端的 pymcadp 倉儲 clone 至近端後, 解開其最新版內容後, 接著就要配合 2017 Fall 的 CP 課程, 在倉儲中的 2017fall 目錄, 存放本學期隨後與課程配合的 Eric6 專案及程式碼, 各學員則配合參考 pymcadp 中的設計與配置, 在自己的倉儲中建立對應的目錄與專案內容. 啟動 Eric6 IDE 在隨身碟中啟動 Eric6 只要點按 start.bat 後, 在命令列中執行 eric6 即可帶出整合開發環境. 之後, 從下拉式功能表中的 Project, 以 New 建立新專案, 使用者必須設定 Project Properties 畫面如下: (以上 2D 圖像表達, 採用 ShareX 擷取視窗區域存成圖檔後, 以 GIMP 編輯, 利用 Rectangle Select Tool 選定要以紅線標示的三個區域後, 再透過 GIMP 的 Edit-Stroke Selection 功能, 選擇標示框線的顏色、大小與樣式) 填入 2017 Fall CP 課程相關 Eric6 程式專案後, Project Properties 視窗畫面如下: 亦即專案名稱設為 calculator, 專案目錄選擇位於 Y:\\tmp\\fossil\\pymcadp\\2017fall, 且 Main Script 設為 run.py 在 Eric6 的 Project-Viewer 視窗中, 前兩個頁面為原始碼頁與表單頁, 原始碼頁畫面如下: 表單頁面如下: 選擇表單頁面後, 以滑鼠右鍵新增表單: (圖檔以 ShareX 取 screenshot 後, 以 Gimp 加入紅色框線後, 以 Dia 加入指向曲線與標註文字) 計算機使用的表單為 Dialog: 將表單相關檔案存入新增的目錄中: 新增表單設定完成後, Eric6 自動開啟 Qt Design 畫面: QAbstractButton Class QLineEdit Class ( PyQt4 的 QLineEdit 說明 ) Layout Management PyQt5 Class reference","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-pyqt5-1.html"},{"title":"第八週課程內容整理","text":"2017 年 Fall 的課程進行到接近一半, 本週整理計算機程式與電腦輔助設計實習的課程相關內容, 說明各種工具的特性與學習重點. 機電資整合教育 計算機程式與電腦輔助設計實習課程的教學目的, 分別從機械、電子與資訊工程等三個領域的相關技術中, 以電腦及網路應用為主軸, 教導學員 了解初步的 Python3 程式語法, 物件導向與事件導向程式的特性 , 能夠建立簡單的視窗程式, 與電腦輔助設計實習中的簡單機電系統配合, 用來 控制虛擬或實際的機構、馬達與感測器所組合而成的裝置 . 其中, 為了推廣學員互相學習, 特別導入軟體組態管理系統, 初期以 Fossil SCM 為主, 最後將與 Github 及 Bitbucket 倉儲進行同步整合. 各班所使用的 Fossil SCM 主機分別為: 計算機程式: https://cpa.kmol.info 與 https://cpb.kmol.info 電腦輔助設計實習: https://cpa.kmol.info 與 https://cadpb.kmol.info 2017 Fall 的計算機程式希望各學員都能自行利用 Eric6 IDE, 建立簡單的 PyQt5 Calculator 視窗程式, 並朝利用程式控制 V-rep 中的機電模擬系統的方向學習. 2017 Fall 的電腦輔助設計實習則利用可攜簡單的 Solvespace, 進行系統機構的原型概念設計後, 再利用 Onshape 進行各組的協同細部設計, 最後則每班預計利用 Arduino 控制卡與伺服馬達及傳動機構, 完成四組鋼球循環運動系統實作, 並且嘗試採用計算機程式課程所完成的 PyQt5 視窗程式, 擷取鋼球通過軌道紅外線偵測點的資訊. 課程工具介紹 本課程在 Windows 10 操作系統中建立可攜的 Python3 程式環境, 各學員可以自行從 http://service.mde.tw/public/python2017fall_36.7z 下載後解壓縮, 放入 USB 3.0 規格以上的隨身碟, 即可利用 start.bat 啟動, 以 stop.bat 終止相關程式, 可攜系統還包括 SciTE 編輯器, 可以直接以解譯方式執行 Python3 程式, 也可以透過 Tiny C, 以類解譯的方式執行 ANSI C 程式. 可攜系統中還包括 Leo Editor、Pelican Blog、Reveal.js、Fossil SCM、Git、Solvespace、V-rep、Blender 等系統, 以下分別介紹其基本功能. Leo Editor 大綱管理系統 Leo Editor 是一套採用 Python 與 PyQt 編寫的大綱管理系統, 在本課程中主要用來建立 Pelican 靜態網誌, 並提供近端 www 伺服器按鈕, 可以讓使用者在近端模擬區域網路或廣域網路上 https 主機所呈現的網頁內容. 此外, Leo Editor 中有 @clean 節點指令, 可用來有效管理 html 多層次標註文件, 讓使用者建立 Reveal.js 網際投影片時, 能夠分區編輯所需的內容, 並且重用各投影片中的各種專用格式架構. 但是 Leo Editor 的存檔格式採用 XML, 各學員在組態管理系統資料改版推送的過程, 必須設法 避免不同版次間的 .leo 檔案產生衝突 , 因為利用視窗套件用來處理 .leo 檔案衝突的程式套件尚未建立, 因此各組學員目前必須採各人一個 .leo 檔案的方式進行協同, 也要避免讓個人的 .leo 在版次提交推送過程產生衝突. Pelican 靜態網誌 網誌是工作歷程的紀錄, 本系列課程特別強調各學員在學習機械設計相關課程的階段, 必須 利用編寫網誌的機會, 訓練自己口語、文字、2D 、3D 與數學表達的能力 . 使用者建立 Pelican 靜態網誌的流程, 採用 Leo Editor 中所建立的套稿, 編寫 Markdown 格式文章, 透過 Leo Editor 中的近端轉檔與遠端轉檔按鈕, 執行 Pelican 指令, 將 Markdown 格式檔案, 依照使用者的設定, 轉換成 html 文件, 使用者可以進一步利用 Leo Editor ˋ中的 IPv4 或 IPV6 WWW 伺服器按鈕, 在近端檢查所完成的 Pelican 靜態網頁, 確定無誤後, 再納入 Disqus 的遠端留言設定, 轉換成準備提交推送到遠端 Fossil SCM 、Github、或 Bitbucket 對應倉儲. Reveal.js 網際簡報 各學員在期中考與期末考週, 必須先行利用 ShareX 拍攝個人簡報內容後, 將影片上傳至 Vimeo 與 Youtube, 在考試時段利用 Reveal.js 簡報個人專題報告內容並自評期中與期末成績. Fossil SCM 組態管理系統 學習 Fossil 最佳的方式就是親自操作使用, fossil.exe 2.3 版檔案大小只有約 6MB, 但是卻提供網際伺服 Html 與 Javascript 檔案與 Wiki 的功能, 也能透過瀏覽器在 Wiki 文章中附加檔案, 各學員必須從個人倉儲熟悉組態管理系統的各項功能後, 在專題製作過程利用 Fossil SCM 進行協同設計. Solvespace、Onshape 與 V-rep 學習這三套系統的最佳途徑 , 就是從各 官方網頁中的 Tutorial 與說明文件中逐步熟習各套件的特性與使用方法 , 並且透過專題製作, 實際應用其功能 , 解決 過程中所面臨的各種 問題 . CP Qt Designer 教學影片 Qt Designer Manual: http://doc.qt.io/qt-5/qtdesigner-manual.html Layout MainWindow Widget Form Preview 一乙第八週上課教學影片: 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第八週第一部分, 說明 Python 物件導向的術語及基本用法 from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第八週第二部分, 利用瀏覽器中的 Brython 程式環境, 練習如何使用 for 迴圈、函式與類別定義. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第八週第三部分, 說明如何利用 Eric6 IDE 建立所需的 calculator 計算機程式對話表單. from 國立虎尾科技大學機械設計工程系 on Vimeo . CADP Onshape 教學影片 基本草圖繪製 零件組立 參數設計 Sweep Tutorial CADP V-rep 教學影片 利用 Python 程式控制 V-rep 動態模型","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-w8-summary.html"},{"title":"CADP 第七週線上考試","text":"W7-W9 週為本學期期中階段的考試週, 其中第一堂課時間將要求學員直接利用教室中的電腦 ,以 ShareX 拍攝與課程相關的操作影片. 第七週上課時間規劃 其餘時間將繼續練習與 PyQt5 計算機程式有關的語法與操作步驟. 第七週考試時間甲乙班 13:20-14:20 考試要求 第一段影片, 請錄下從隨身碟啟動系統開始, 到完成新增第七週個人倉儲網誌中的學習心得為止. 網誌標題為, 電腦輔助設計實習第七週學習心得 網誌 html 檔名為, 學號-w7-exam 過程中必須利用 SciTE 在螢幕右下方呈現各階段摘要說明, 說明最後則寫上\"W7-學號-正在考試\" 字樣. 第一段影片名稱: 學號-w7-exam-1.mp4 完成 mp4 檔案拍攝後, 必須冠上校名-系名-課程名稱-學號, 之後同時上傳到以個人學號註冊的 Vimeo 及 Youtube 影片存放區. 第二段影片, 請根據 https://hp.kmol.info:8443/get_page/Angle%20Bracket 中的導引說明, 在現場一個步驟接一個步驟, 以切換說明引導的方式, 錄下個人繪製零件的過程. 第二段影片名稱: 學號-w7-exam-2.mp4 完成 mp4 檔案拍攝後, 必須冠上校名-系名-課程名稱-學號, 之後同時上傳到以個人學號註冊的 Vimeo 及 Youtube 影片存放區. 第三段影片, 請利用個人先前所繪製的 Nutcracker 零件, 在 Solvespace 中完成組立, 每個零件的導入與定位過程均要採用 SciTE 文字說明組立所使用的約束條件與操作步驟. 第三段影片名稱: 學號-w7-exam-3.mp4 完成 mp4 檔案拍攝後, 必須冠上校名-系名-課程名稱-學號, 之後同時上傳到以個人學號註冊的 Vimeo 及 Youtube 影片存放區. 影片嵌入個人網誌 完成上述個人操作影片拍攝後, 必須改版上述第七週學習心得網誌中, 然後寫上其他操作心得後, 根據課程的評分規劃, 列出各項具體證據後, 在網誌中寫上自評期中成績. Nutcracker 輸入 V-rep 本週各學員將學會如何: 啟動 V-rep 如何將 Nutcracker 零組件輸入 V-rep 如何 divide 所輸入的 stl 零組件 如何將 revolute joint 套入預留的圓柱體軸位置 如何設定各零件的從屬關係 如何進行初步的 Nutcracker 運動模擬 各學員學會上述各項操作後, 請在下課之前利用 ShareX 拍攝個人的練習過程, 並嵌入個人網誌中後, 註記學習心得.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-cadp-w7-exam.html"},{"title":"CP 第七週線上考試","text":"W7-W9 週為本學期期中階段的考試週, 其中第一堂課時間將要求學員直接利用教室中的電腦 ,以 ShareX 拍攝與課程相關的操作影片. 第七週上課時間規劃 其餘時間將繼續練習與 PyQt5 計算機程式有關的語法與操作步驟. 第七週考試時間乙班 13:30-14:00, 甲班 08:20-08:50 考試要求 請錄下從隨身碟啟動系統開始, 到完成新增第七週個人倉儲網誌中的學習心得為止. 網誌標題為 計算機程式第七週學習心得 網誌 html 檔名為 學號-w7-exam 過程中必須利用 SciTE 在螢幕右下方呈現各階段摘要說明, 說明最後則寫上\"W7-學號-正在考試\" 字樣. 完成 mp4 檔案拍攝後, 必須冠上校名-系名-課程名稱-學號, 之後同時上傳到以個人學號註冊的 Vimeo 及 Youtube 影片存放區. 影片嵌入個人網誌 完成上述個人操作影片拍攝後, 必須改版上述第七週學習心得網誌中, 然後寫上其他操作心得後, 根據課程的評分規劃, 列出各項具體證據後, 在網誌中寫上自評期中成績. 考試範例影片: cpb 4062 W7 考試 from 國立虎尾科技大學機械設計工程系 on Vimeo . 電腦輔助設計室上網設定: 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第七週第一部分, 說明有關電腦輔助設計室電腦網路連線設定與查驗指令. from 國立虎尾科技大學機械設計工程系 on Vimeo . 變數命名規格, 函式定義與呼叫 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第七週第二部分, 說明 Python 變數命名規格, 關鍵字以及如何利用重複迴圈定義列印字串的 diamond 函式. from 國立虎尾科技大學機械設計工程系 on Vimeo . Eric6 與 PyQt5 本週各學員將學會如何: 啟動 Eric6 如何建立 Eric6 專案 如何建立 Python3 程式碼 如何執行 Python3 程式碼 利用 Qt Designer 建立計算機表單 如何編譯表單 .ui 檔案, 建立對應的 Python 程式 各學員學會上述各項操作後, 請在下課之前利用 ShareX 拍攝個人的練習過程, 並嵌入個人網誌中後, 註記學習心得.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-cp-w7-exam.html"},{"title":"KMOL 整合課程介紹","text":"KMOL 是 KMOUL 的簡寫, 全文為 Knowledge Management and Optimal Utilization Laboratory, 也就是 知識管理與最佳化應用實驗室 (KMOLab). 目前由 KMOL 實驗室負責的課程有大一的計算機程式與網際內容管理, 以及大二的電腦輔助設計實習與協同產品設計實習. 知識管理與最佳化應用 知識亦即經由學習、經驗或仔細審查之過程, 得以針對特定主題, 了解事實真相或原理原則之能力 . 知識的應用則必須在特定情況下, 用於辨別情境後, 找出方法, 進而解決問題. 由於知識概分為外顯知識與內隱知識, 所謂外顯知識, 就是已經被詳細紀載, 可以單獨經由閱讀獲得, 但是內隱知識則並未或無需明講, 但在不同群體與文化傳承之下, 不言可喻或尚無法準確描述或傳承的認知、理念或價值. 知識之所以必須有效管理, 原因在於傳承、應用與持續改進之必要 . 尤其在二十一世紀網路通訊普及、高速實體載運發達、數位運算能力大幅提升, 以及全球協同的模式下, 使得 各類產品與知識的生命週期縮短, 各領域知識多元整合與衝擊下, 各團隊必須共同面對許多問題的解決, 互助共享知識的應用 , 方得長治久安. 所謂知識的最佳化應用, 即在上述多元且複雜的情境下, 善用數位網路與運算方法, 找出最具價值的知識應用模式, 透過 持續改進且能永續長存的虛實整合系統 (Cyber & Physical Integrated System), 解決各種問題. KMOLab 課程教育目標 在善用數位網路與運算方法, 逐步建構虛實整合系統方針下, KMOLab 希望透過 計算機程式課程, 讓使用者有能力利用電腦及網路溝技術, 以電腦程式建置初步的系統與套件 , 在持續改進與永續長存的理念下, 導入組態管理系統 (Configuration Management System), 明確利用歷程資訊, 保存系統組成元件的建置過程, 並 訓練學員善用口語、文字、2D、3D、數學與實體表達各階段之設計與實作狀態 . 網際內容管理課程則讓學員從電腦硬體的拆解、網路線的製作與連線設定及配置開始 ,進而安裝操作系統, 並 透過電腦程式建構能在網際環境中管理機械設計資訊的伺服套件 . 電腦輔助設計實習與協同產品設計實習課程, 則是讓學員 從各種開放套件的使用, 學習從數位模擬到機電資協同整合設計過程, 如何透過專題製作解決各種問題 . KMOLab 使用工具 程式語言: Python 3、C/C++、Javascript、Brython 電腦輔助設計: Solvespace、Onshape、V-rep 、Blender 軟體組態管理: Fossil SCM、Github、Bitbucket 個人資訊管理: Leo Editor、Pelican Blog、Reveal.js、Jupyterlab 圖形介面: PyQt5、Web-based 內容管理: CMSimfly、Pygrouf","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-integrated-course-introduction.html"},{"title":"2017 Fall CP 第六週 - Python3 程式語法練習","text":"本週起開始使用 Eric6 IDE 建立 PyQt5 視窗程式, 計算器程式的圖形介面將從 Qt Designer 中, 以滑鼠及視覺化模式建立, 之後再轉為 .py 程式後, 與隨後的程式邏輯進行互動. 請使用者自行下載 Lean Python 電子書與 範例程式 配合學習. 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第六週第一部分, 從最原始的 fossil init 在伺服器建立倉儲開始, 說明如何建立網誌與投影片架構. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第六週第二部分, 說明當使用 Fossil SCM 倉儲時, 如何在操作系統與 Pelican 轉檔過程正確改版. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第六週第三部分, 說明如何 git clone Github 上的倉儲, 如何使用 eric6 IDE 開始開發 PyQt5 程式. from 國立虎尾科技大學機械設計工程系 on Vimeo . canvas { border: 1px solid black; } window.onload=function(){ brython({debug:1, pythonpath:['./../data/py']}); } function doSave(storage_id, filename){ var blob = new Blob([localStorage[storage_id]], {type: \"text/plain;charset=utf-8\"}); filename = document.getElementById(filename).value saveAs(blob, filename+\".py\"); } 編寫 Python3 程式邏輯之前必須先了解基本的程式語法, 其中包括: Python3 變數命名規則與關鍵字 Python 英文變數命名規格 變數必須以英文字母大寫或小寫或底線開頭 變數其餘字元可以是英文大小寫字母, 數字或底線 變數區分英文大小寫 變數不限字元長度 不可使用關鍵字當作變數名稱 使用者可以利用以下程式列出所使用 Python 的版次與關鍵字: from browser import document as doc import ace # Brython 3.3.4 內建的 container 名稱為 'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id Ace = ace.Editor(editor_id=\"kw_editor\", console_id=\"kw_console\", container_id=\"kw__container\", storage_id=\"kw_py_src\" ) Ace.editor.setValue('''# 導入 sys 模組 import sys # 導入 keyword 模組 import keyword # 利用 sys 模組中的 version_info 印出 Python 版次 print(\"Python version: \", sys.version_info) # 利用 keyword 模組中的 kwlist 印出關鍵字 print(\"Python keywords: \", keyword.kwlist) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['kw_run'].bind('click', Ace.run) doc['kw_show_console'].bind('click', Ace.show_console) doc['kw_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 Python3 的程式關鍵字, 使用者命名變數時, 必須避開下列保留字. Python keywords: ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 選擇好的變數名稱: 使用有意義且適當長度的變數名稱， 例如: 使用 length 代表長度, 不要單獨使用 l 或 L, 也不要使用 this_is_the_length 程式前後變數命名方式盡量一致, 例如: 使用 rect_length 或 RectLength 用底線開頭的變數通常具有特殊意義 print() 函式用法 print() 為 Python 程式語言中用來列印數值或字串的函式, 其中有 sep 變數定義分隔符號, ｓep 內定為 \",\", end 變數則用來定義列印結尾的符號, end 內定為跳行符號. for 迴圈用法與 Python 的縮排規定 重複迴圈用法, 使用者可以透過下列程式編輯區練習 for 迴圈與 print() 函式的用法. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"editor\", console_id=\"console\", container_id=\"first_container\", storage_id=\"py_src\" ) Ace.editor.setValue('''#ex1 簡單的 for 迴圈範例 for i in range(10): print(i) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['run'].bind('click', Ace.run) doc['show_console'].bind('click', Ace.show_console) doc['clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 下列的 Brython turtle 網際繪圖程式僅提供參考, 可以用來練習 Python3 程式語法. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"turtle_editor\", console_id=\"turtle_console\", container_id=\"container\", storage_id=\"turtle_py_src\" ) Ace.editor.setValue('''import turtle t=turtle.Turtle() t.penup() t.left(45) t.backward(125) t.right(45) t.pendown() for c in ['red', 'green', 'yellow', 'blue']: t.color(c) t.forward(75) t.left(90) t1=turtle.Turtle(\"turtle\") t1.penup() t1.pendown() t1.width(3) for c in ['red', 'blue', 'yellow', 'green', 'purple', 'brown']: t1.color(c) t1.forward(50) t1.left(60) t1.penup() t1.left(60) t1.backward(120) t1.pendown() t1.color('red') t1.write(\"I love Brython!!\") turtle._Screen().end() ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) doc['turtle_run'].bind('click', Ace.run) doc['turtle_show_console'].bind('click', Ace.show_console) doc['turtle_clear_console'].bind('click', Ace.clear_console) doc['turtle_clear_container'].bind('click', Ace.clear_container) Filename: .py Run Output 清除 清除畫布 函式用法與呼叫 使用者可以利用下列程式, 練習 def 函式定義與呼叫的用法. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"fun_editor\", console_id=\"fun_console\", container_id=\"fun_container\", storage_id=\"fun_py_src\" ) Ace.editor.setValue('''# 定義函式 def square_of_x(x): return x*x # 呼叫函式 y = square_of_x(3) # 列印 y 對應內容 print(y) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['fun_run'].bind('click', Ace.run) doc['fun_show_console'].bind('click', Ace.show_console) doc['fun_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 以下網際繪圖程式, 僅提供參考. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"by_editor\", console_id=\"by_console\", container_id=\"by_container\", storage_id=\"by_py_src\" ) Ace.editor.setValue('''# First of all, the import of some libraries from browser import document as doc from browser import html # All the elements will be inserted in the div with the \"container\" id container = doc['by_container'] # We create a new div element newdiv = html.DIV(id = \"new-div\") # Now we add some style newdiv.style = {\"padding\": \"5px\", \"backgroundColor\": \"#ADD8E6\"} # Now, lets add a table with a column with numbers and a # column with a word on each cell text = \"Brython is really cool\" textlist = text.split() table = html.TABLE() for i, word in enumerate(textlist): table <= html.TR(html.TD(i + 1) + html.TD(word)) # Now we add some style to the table table.style = {\"padding\": \"5px\", \"backgroundColor\": \"#aaaaaa\", \"width\": \"100%\"} # Now we add the table to the new div previously created newdiv <= table + html.BR() # a form? why not? form = html.FORM() input1 = html.INPUT(type=\"text\", name=\"firstname\", value=\"First name\") input2 = html.INPUT(type=\"text\", name=\"lastname\", value=\"Last name\") input3 = html.BUTTON(\"Button with no action!\") form <= input1 + html.BR() + input2 + html.BR() + input3 newdiv <= form + html.BR() # Finally, we will add something more 'HTML5istic', a canvas with # a color gradient in the newdiv previously created and below the form canvas = html.CANVAS(width = 300, height = 300) #canvas.style = {\"width\": \"100%\"} ctx = canvas.getContext('2d') ctx.rect(0, 0, 300, 300) grd = ctx.createRadialGradient(150, 150, 10, 150, 150, 150) grd.addColorStop(0, '#8ED6FF') grd.addColorStop(1, '#004CB3') ctx.fillStyle = grd ctx.fill() newdiv <= canvas # And finally we append the newdiv element # to the parent, in this case the div with the \"container\" id container <= newdiv ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['by_run'].bind('click', Ace.run) doc['by_show_console'].bind('click', Ace.show_console) doc['by_clear_console'].bind('click', Ace.clear_console) doc['by_clear_container'].bind('click', Ace.clear_container) Filename: .py Run Output 清除 清除畫布 以下網際動態繪圖程式, 僅提供參考. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"clock_editor\", console_id=\"clock_console\", container_id=\"clock_container\", storage_id=\"clock_py_src\" ) Ace.editor.setValue('''# First of all, the import of some libraries import time import math import datetime from browser import document as doc import browser.timer from browser import html sin,cos = math.sin,math.cos width,height = 250,250 # canvas dimensions ray = 100 # clock ray # All the elements will be inserted in the div with the \"container\" id container = doc['clock_container'] # We create a new div element newdiv = html.DIV(id = \"new-div\") # Now we add some style newdiv.style = {\"padding\": \"5px\", \"backgroundColor\": \"#ADD8E6\"} canvas = html.CANVAS(width = width, height = height) #canvas.style = {\"width\": \"100%\"} ctx = canvas.getContext('2d') def needle(angle,r1,r2,color=\"#000000\"): # draw a needle at specified angle in specified color # r1 and r2 are percentages of clock ray x1 = width/2-ray*cos(angle)*r1 y1 = height/2-ray*sin(angle)*r1 x2 = width/2+ray*cos(angle)*r2 y2 = height/2+ray*sin(angle)*r2 ctx.beginPath() ctx.strokeStyle = color ctx.moveTo(x1,y1) ctx.lineTo(x2,y2) ctx.stroke() def set_clock(): # erase clock ctx.beginPath() ctx.fillStyle = \"#FFF\" ctx.arc(width/2,height/2,ray*0.89,0,2*math.pi) ctx.fill() # redraw hours show_hours() # print day now = datetime.datetime.now() day = now.day ctx.font = \"bold 14px Arial\" ctx.textAlign = \"center\" ctx.textBaseline = \"middle\" ctx.fillStyle=\"#FFF\" ctx.fillText(day,width*0.7,height*0.5) # draw needles for hour, minute, seconds ctx.lineWidth = 3 hour = now.hour%12 + now.minute/60 angle = hour*2*math.pi/12 - math.pi/2 needle(angle,0.05,0.5) minute = now.minute angle = minute*2*math.pi/60 - math.pi/2 needle(angle,0.05,0.85) ctx.lineWidth = 1 second = now.second+now.microsecond/1000000 angle = second*2*math.pi/60 - math.pi/2 needle(angle,0.05,0.85,\"#FF0000\") # in red browser.timer.set_interval(set_clock,100) ctx.beginPath() ctx.lineWidth = 10 ctx.arc(width/2,height/2,ray,0,2*math.pi) ctx.stroke() for i in range(60): ctx.lineWidth = 1 if i%5 == 0: ctx.lineWidth = 3 angle = i*2*math.pi/60 - math.pi/3 x1 = width/2+ray*cos(angle) y1 = height/2+ray*sin(angle) x2 = width/2+ray*cos(angle)*0.9 y2 = height/2+ray*sin(angle)*0.9 ctx.beginPath() ctx.moveTo(x1,y1) ctx.lineTo(x2,y2) ctx.stroke() def show_hours(): ctx.beginPath() ctx.arc(width/2,height/2,ray*0.05,0,2*math.pi) ctx.fillStyle = \"#000\" ctx.fill() for i in range(1,13): angle = i*math.pi/6-math.pi/2 x3 = width/2+ray*cos(angle)*0.75 y3 = height/2+ray*sin(angle)*0.75 ctx.font = \"20px Arial\" ctx.textAlign = \"center\" ctx.textBaseline = \"middle\" ctx.fillText(i,x3,y3) # cell for day ctx.fillStyle = \"#000\" ctx.fillRect(width*0.65,height*0.47,width*0.1,height*0.06) show_hours() set_clock() newdiv <= canvas # And finally we append the newdiv element # to the parent, in this case the div with the \"container\" id container <= newdiv ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['clock_run'].bind('click', Ace.run) doc['clock_show_console'].bind('click', Ace.show_console) doc['clock_clear_console'].bind('click', Ace.clear_console) doc['clock_clear_container'].bind('click', Ace.clear_container) Filename: .py Run Output 清除 清除畫布 基本物件導向與案例 Python 採用類別 (class) 將案例變數 (instance variables) 與案例方法 (instance methods) 包在一起, 並用來定義一種物件 (object). 物件導向具有封裝 (encapsulation) , 繼承 (inheritance) 與多形 ( polymorphism) 等三種特性. 使用者可以利用下列程式練習 Python3 物件的定義與應用. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"oop1_editor\", console_id=\"oop1_console\", container_id=\"oop1_container\", storage_id=\"oop1_py_src\" ) Ace.editor.setValue('''# Robot class 定義 class Robot(object): def __init__(self, name, by): self._name = name self._build_year = by @property def name(self): return self._name @name.setter def name(self, newname): self._name = name @property def build_year(self): return self._build_year @build_year.setter def build_year(self, newby): self._build_year = newby x = Robot(\"bob\", 1993) x.build_year = 1993 print(x.name) print(x.build_year) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['oop1_run'].bind('click', Ace.run) doc['oop1_show_console'].bind('click', Ace.show_console) doc['oop1_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 以下平面機構動態模擬程式, 僅提供參考. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"link_editor\", console_id=\"link_console\", container_id=\"fourbar\", storage_id=\"link_py_src\" ) Ace.editor.setValue('''# 導入所需模組 from browser import document as doc from browser import window from browser import timer from browser import html import math # 利用 window 擷取 PrairieDraw 程式庫變數物件, 然後以 new 方法轉為 Brython 變數 pdraw = window.PrairieDraw.new # 利用 window 擷取 PrairieDrawAnim 程式庫變數物件, 然後以 new 方法轉為 Brython 變數 PrairieDrawAnim = window.PrairieDrawAnim.new # 利用 window 擷取 sylvester 程式庫變數物件 Vector, 並將其 create 方法直接轉為 Brython 變數 # 在 sylvester 中的 $V 簡化變數無法直接在 Brython 程式中引用 vector = window.Vector.create # 在 \"fourbar\" 畫布中建立 panim 動態模擬案例 panim = PrairieDrawAnim(\"fourbar\") # 平面連桿繪圖以 t = 0 起始 t = 0 # 控制轉動方向變數 direction = True # 繪製不同 t 時間下的平面連桿 def draw(): global t, direction, fast # 設定模擬繪圖範圍 panim.setUnits(6, 6) # 設定箭頭線寬 panim.setProp(\"arrowLineWidthPx\",2) # 起始變數設定 omega = 1 length_bar1 = 1 length_bar2 = 26/18 length_bar3 = 2 length_base = 40/18 time = 0 # 畫出地面直線 G = vector([0, -0.5]) panim.ground(G, vector([0, 1]), 10) # 連桿長度與角度計算 A = t*omega # \"theta\" AD = length_bar1 #length of left bar AB = length_base #distance between two stationary pivots BC = length_bar3 #length of right bar CD = length_bar2 #length of middle bar BD = math.sqrt(AD*AD + AB*AB - 2*AD*AB*math.cos(A)) C = math.acos((BC*BC + CD*CD - BD*BD)/(2*BC*CD)) ABD = math.asin(CD * math.sin(C) / BD) DBC = math.asin(AD * math.sin(A) / BD) B = ABD + DBC D = math.pi - B - C # draw pivot pivot_left = vector([AB/-2, 0]) pivot_right = vector([AB/2, 0]) panim.pivot(vector([pivot_left.e(1), -0.5]), pivot_left, 0.5) panim.pivot(vector([pivot_right.e(1), -0.5]), pivot_right, 0.5) # 儲存轉換矩陣 panim.save() #FIRST BAR panim.translate(pivot_left) panim.rotate(A) panim.rod(vector([0,0]), vector([AD,0]), 0.25) panim.point(vector([0,0])) #SECOND BAR panim.translate(vector([AD,0])) panim.rotate(A*-1) #\"undo\" the original A rotation panim.rotate(D) #rotate by D only panim.rod(vector([0,0]), vector([CD,0]), 0.25) panim.point(vector([0,0])) #THIRD BAR panim.translate(vector([CD,0])) panim.rotate(math.pi+C) panim.rod(vector([0,0]), vector([BC,0]), 0.25) panim.point(vector([0,0])) # 回復原先的轉換矩陣 panim.restore() panim.point(vector([pivot_right.e(1), 0])) # 時間增量 if direction == True: t += 0.08 else: t += -0.08 # 先畫出 t = 0 的連桿機構 draw() # 將 anim 設為 None anim = None def launchAnimation(ev): global anim # 初始啟動, anim 為 None if anim is None: # 每 0.08 秒執行一次 draw 函式繪圖 anim = timer.set_interval(draw, 80) # 初始啟動後, 按鈕文字轉為\"暫停\" doc['power'].text = '暫停' elif anim == 'hold': # 當 anim 為 'hold' 表示曾經暫停後的啟動, 因此持續以 set_interval() 持續旋轉, 且將 power 文字轉為\"暫停\" anim = timer.set_interval(draw, 80) doc['power'].text = '暫停' else: # 初始啟動後, 使用者再按 power, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停 # 且將 anim 變數設為 'hold', 且 power 文字轉為\"繼續\" timer.clear_interval(anim) anim = 'hold' doc['power'].text = '繼續' def reverse(ev): global anim, direction # 當 anim 為 hold 時, 按鈕無效 if anim != \"hold\": if direction == True: direction = False else: direction = True doc[\"power\"].bind(\"click\", launchAnimation) doc[\"reverse\"].bind(\"click\", reverse) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['link_run'].bind('click', Ace.run) doc['link_show_console'].bind('click', Ace.show_console) doc['link_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 啟動 反向 目前所在頁面, 分別利用 Brython 與 Ace.js 編輯器, 可直接在網誌中執行 Python3 程式, 基本架構為將 Brython 的標準輸出轉到特定 div 標註, 而 Ace.js 編輯器則設為與其內的程式碼相同長度, 但至多只會在頁面中顯示 20 行, 且編輯器內的程式碼使用 12 號字元. ace.py 原始碼, 位於 data/py 目錄中, 將原先只能單一呼叫的函式改為物件, 可以在同一頁面中產生案例時, 透過各標註的 id 字串區分各段程式碼, 是本課程 Python3 物件導向程式的實際應用範例, 僅提供參考. import sys import time import traceback import javascript from browser import document as doc, window, alert if hasattr(window, 'localStorage'): from browser.local_storage import storage else: storage = None class cOutput: def __init__(self, target): self.target = doc[target] def write(self, data): self.target.value += str(data) class Editor(): def __init__(self, editor_id, console_id, container_id, storage_id): self.editor_id = editor_id self.console_id = console_id self.container_id = container_id self.storage_id = storage_id self.output = '' try: self.editor = window.ace.edit(self.editor_id) session = self.editor.getSession() session.setMode(\"ace/mode/python\") self.editor.setOptions({ 'enableLiveAutocompletion': True, 'enableSnippets': True, 'highlightActiveLine': False, 'highlightSelectedWord': True, 'autoScrollEditorIntoView': True, # 'maxLines': session.getLength() 可以根據程式長度設定 editor 列數 # 設定讓使用者最多可以在畫面中顯示 20 行程式碼 'maxLines': 20, 'fontSize': '12pt' }) except: from browser import html self.editor = html.TEXTAREA(rows=20, cols=70) doc[self.editor_id] <= self.editor def get_value(): return self.editor.value def set_value(x): self.editor.value = x self.editor.getValue = get_value self.editor.setValue = set_value def run(self, *args): sys.stdout = cOutput(self.console_id) sys.stderr = cOutput(self.console_id) doc[self.console_id].value = '' src = self.editor.getValue() if storage is not None: storage[self.storage_id] = src t0 = time.perf_counter() try: #ns = {'__name__':'__main__'} # 以 self.editor_id 名稱執行程式 ns = {'__name__': self.editor_id} exec(src, ns) state = 1 except Exception as exc: traceback.print_exc(file=sys.stderr) state = 0 self.output = doc[self.console_id].value print('<completed in %6.2f ms>' % ((time.perf_counter() - t0) * 1000.0)) return state def show_console(self, ev): doc[self.console_id].value = self.output doc[self.console_id].cols = 60 doc[self.console_id].rows = 10 def clear_console(self, ev): doc[self.console_id].value = \"\" def clear_container(self, ev): doc[self.container_id].clear() # load a Python script def load_script(self, evt): _name = evt.target.value + '?foo=%s' % time.time() self.editor.setValue(open(_name).read())","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-course-cp-w6.html"},{"title":"2017 Fall CADP 第五週 - Solvespace & V-rep","text":"本週起各學員開始利用 Solvesapce 建立 Nutcracker 系統的零組件, 並且將所完成的零組件顯示在網誌中, 並提供 .slvs 檔案下載. 請各學員在完成各零件繪圖與組立時, 將練習影片上傳到個人 Vimeo 與 Youtube 區, 並清楚標定影片標題與簡介, 各影片必須明確顯示校名、系名、課程名稱與使用者學號等資訊, 並在各影片的內容說明連回自己的網誌. Solvespace 零件繪圖導引 Solvespace 零件組立導引 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第五週第一部分, 利用 Javascript 可以將上傳到版次管理的 stl 格式連件檔案直接在瀏覽器中展示, 使用者也可以透過連結提供 slvs 零件檔案的下載. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第五週第二部分, 透過 Solvespace 官方網站的 tutorial 練習零件繪製與零件組立. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二乙第五週第二部分, 完成 Solvespace 零組件繪圖後, 可以利用 triangle mesh 格式, 以 stl 或 three.js 檢視的 html 格式輸出. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二乙第五週第三部分, 當使用者在 Solvespace 完成 Nutcracker 零組件繪製與組立後, 可以轉進 V-rep 進行動態模擬. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二甲第六週, 登錄 Onshape 帳號, 並且設法完成 Nutcracker 零組件繪圖, 並計算零件運動範圍. from 國立虎尾科技大學機械設計工程系 on Vimeo . angle_bracket_tutorial from 國立虎尾科技大學機械設計工程系 on Vimeo . assembly tutorial from 國立虎尾科技大學機械設計工程系 on Vimeo . 各零件間的運動模擬, 可以仿 https://stemkoski.github.io/Three.js/Model-Animation-Control.html ( 倉儲 ) 及 網際零組件動態模擬技術 達成.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-course-cadp-w5.html"},{"title":"2017 Fall CP 第五週 - PyQt5 Calculator","text":"W5 PyQt5 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第五週, 本週開始利用 eric6 IDE 學習如何利用 PyQt5 建立計算器視窗程式, 並利用網誌展示程式碼. from 國立虎尾科技大學機械設計工程系 on Vimeo . 在網誌中使用 <pre class=\"brush: python\"></pre> 標註可高亮度顯示 Python 語法, 並加上行數展示程式碼: #!/usr/bin/env python # 當系統安裝多套 Python 解譯器時可以利用上一行指定執行的 Python 版本 # 導入 math 模組 import math # 導入所需的 PyQt5 模組 from PyQt5.QtCore import Qt from PyQt5.QtWidgets import (QApplication, QGridLayout, QLayout, QLineEdit, QSizePolicy, QToolButton, QWidget) # 建立 Button 物件, 且繼承自 QToolButton 物件 class Button(QToolButton): ''' def __init__(self, text, parent=None): super(Button, self).__init__(parent) ''' # for Python 3 def __init__(self, text): super().__init__() self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred) self.setText(text) def sizeHint(self): size = super(Button, self).sizeHint() size.setHeight(size.height() + 20) size.setWidth(max(size.width(), size.height())) return size class Calculator(QWidget): NumDigitButtons = 10 ''' def __init__(self, parent=None): super(Calculator, self).__init__(parent) ''' def __init__(self): super().__init__() self.pendingAdditiveOperator = '' self.pendingMultiplicativeOperator = '' self.sumInMemory = 0.0 self.sumSoFar = 0.0 self.factorSoFar = 0.0 self.waitingForOperand = True self.display = QLineEdit('0') self.display.setReadOnly(True) self.display.setAlignment(Qt.AlignRight) self.display.setMaxLength(15) font = self.display.font() font.setPointSize(font.pointSize() + 8) self.display.setFont(font) self.digitButtons = [] for i in range(Calculator.NumDigitButtons): self.digitButtons.append(self.createButton(str(i), self.digitClicked)) self.pointButton = self.createButton(\".\", self.pointClicked) self.changeSignButton = self.createButton(u\"\\N{PLUS-MINUS SIGN}\", self.changeSignClicked) self.backspaceButton = self.createButton(\"Backspace\", self.backspaceClicked) self.clearButton = self.createButton(\"Clear\", self.clear) self.clearAllButton = self.createButton(\"Clear All\", self.clearAll) self.clearMemoryButton = self.createButton(\"MC\", self.clearMemory) self.readMemoryButton = self.createButton(\"MR\", self.readMemory) self.setMemoryButton = self.createButton(\"MS\", self.setMemory) self.addToMemoryButton = self.createButton(\"M+\", self.addToMemory) self.divisionButton = self.createButton(u\"\\N{DIVISION SIGN}\", self.multiplicativeOperatorClicked) self.timesButton = self.createButton(u\"\\N{MULTIPLICATION SIGN}\", self.multiplicativeOperatorClicked) self.minusButton = self.createButton(\"-\", self.additiveOperatorClicked) self.plusButton = self.createButton(\"+\", self.additiveOperatorClicked) self.squareRootButton = self.createButton(\"Sqrt\", self.unaryOperatorClicked) self.powerButton = self.createButton(u\"x\\N{SUPERSCRIPT TWO}\", self.unaryOperatorClicked) self.reciprocalButton = self.createButton(\"1/x\", self.unaryOperatorClicked) self.equalButton = self.createButton(\"=\", self.equalClicked) mainLayout = QGridLayout() mainLayout.setSizeConstraint(QLayout.SetFixedSize) mainLayout.addWidget(self.display, 0, 0, 1, 6) mainLayout.addWidget(self.backspaceButton, 1, 0, 1, 2) mainLayout.addWidget(self.clearButton, 1, 2, 1, 2) mainLayout.addWidget(self.clearAllButton, 1, 4, 1, 2) mainLayout.addWidget(self.clearMemoryButton, 2, 0) mainLayout.addWidget(self.readMemoryButton, 3, 0) mainLayout.addWidget(self.setMemoryButton, 4, 0) mainLayout.addWidget(self.addToMemoryButton, 5, 0) for i in range(1, Calculator.NumDigitButtons): row = ((9 - i) / 3) + 2 column = ((i - 1) % 3) + 1 mainLayout.addWidget(self.digitButtons[i], row, column) mainLayout.addWidget(self.digitButtons[0], 5, 1) mainLayout.addWidget(self.pointButton, 5, 2) mainLayout.addWidget(self.changeSignButton, 5, 3) mainLayout.addWidget(self.divisionButton, 2, 4) mainLayout.addWidget(self.timesButton, 3, 4) mainLayout.addWidget(self.minusButton, 4, 4) mainLayout.addWidget(self.plusButton, 5, 4) mainLayout.addWidget(self.squareRootButton, 2, 5) mainLayout.addWidget(self.powerButton, 3, 5) mainLayout.addWidget(self.reciprocalButton, 4, 5) mainLayout.addWidget(self.equalButton, 5, 5) self.setLayout(mainLayout) self.setWindowTitle(\"Calculator\") def digitClicked(self): clickedButton = self.sender() digitValue = int(clickedButton.text()) if self.display.text() == '0' and digitValue == 0.0: return if self.waitingForOperand: self.display.clear() self.waitingForOperand = False self.display.setText(self.display.text() + str(digitValue)) def unaryOperatorClicked(self): clickedButton = self.sender() clickedOperator = clickedButton.text() operand = float(self.display.text()) if clickedOperator == \"Sqrt\": if operand < 0.0: self.abortOperation() return result = math.sqrt(operand) elif clickedOperator == u\"x\\N{SUPERSCRIPT TWO}\": result = math.pow(operand, 2.0) elif clickedOperator == \"1/x\": if operand == 0.0: self.abortOperation() return result = 1.0 / operand self.display.setText(str(result)) self.waitingForOperand = True def additiveOperatorClicked(self): clickedButton = self.sender() clickedOperator = clickedButton.text() operand = float(self.display.text()) if self.pendingMultiplicativeOperator: if not self.calculate(operand, self.pendingMultiplicativeOperator): self.abortOperation() return self.display.setText(str(self.factorSoFar)) operand = self.factorSoFar self.factorSoFar = 0.0 self.pendingMultiplicativeOperator = '' if self.pendingAdditiveOperator: if not self.calculate(operand, self.pendingAdditiveOperator): self.abortOperation() return self.display.setText(str(self.sumSoFar)) else: self.sumSoFar = operand self.pendingAdditiveOperator = clickedOperator self.waitingForOperand = True def multiplicativeOperatorClicked(self): clickedButton = self.sender() clickedOperator = clickedButton.text() operand = float(self.display.text()) if self.pendingMultiplicativeOperator: if not self.calculate(operand, self.pendingMultiplicativeOperator): self.abortOperation() return self.display.setText(str(self.factorSoFar)) else: self.factorSoFar = operand self.pendingMultiplicativeOperator = clickedOperator self.waitingForOperand = True def equalClicked(self): operand = float(self.display.text()) if self.pendingMultiplicativeOperator: if not self.calculate(operand, self.pendingMultiplicativeOperator): self.abortOperation() return operand = self.factorSoFar self.factorSoFar = 0.0 self.pendingMultiplicativeOperator = '' if self.pendingAdditiveOperator: if not self.calculate(operand, self.pendingAdditiveOperator): self.abortOperation() return self.pendingAdditiveOperator = '' else: self.sumSoFar = operand self.display.setText(str(self.sumSoFar)) self.sumSoFar = 0.0 self.waitingForOperand = True def pointClicked(self): if self.waitingForOperand: self.display.setText('0') if \".\" not in self.display.text(): self.display.setText(self.display.text() + \".\") self.waitingForOperand = False def changeSignClicked(self): text = self.display.text() value = float(text) if value > 0.0: text = \"-\" + text elif value < 0.0: text = text[1:] self.display.setText(text) def backspaceClicked(self): if self.waitingForOperand: return text = self.display.text()[:-1] if not text: text = '0' self.waitingForOperand = True self.display.setText(text) def clear(self): if self.waitingForOperand: return self.display.setText('0') self.waitingForOperand = True def clearAll(self): self.sumSoFar = 0.0 self.factorSoFar = 0.0 self.pendingAdditiveOperator = '' self.pendingMultiplicativeOperator = '' self.display.setText('0') self.waitingForOperand = True def clearMemory(self): self.sumInMemory = 0.0 def readMemory(self): self.display.setText(str(self.sumInMemory)) self.waitingForOperand = True def setMemory(self): self.equalClicked() self.sumInMemory = float(self.display.text()) def addToMemory(self): self.equalClicked() self.sumInMemory += float(self.display.text()) def createButton(self, text, member): button = Button(text) button.clicked.connect(member) return button def abortOperation(self): self.clearAll() self.display.setText(\"####\") def calculate(self, rightOperand, pendingOperator): if pendingOperator == \"+\": self.sumSoFar += rightOperand elif pendingOperator == \"-\": self.sumSoFar -= rightOperand elif pendingOperator == u\"\\N{MULTIPLICATION SIGN}\": self.factorSoFar *= rightOperand elif pendingOperator == u\"\\N{DIVISION SIGN}\": if rightOperand == 0.0: return False self.factorSoFar /= rightOperand return True if __name__ == '__main__': import sys app = QApplication(sys.argv) calc = Calculator() calc.show() sys.exit(app.exec_())","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-course-cp-w5.html"},{"title":"2017 Fall CP 第四週 - Brython 程式環境","text":"本週開始將利用 Python3 與 PyQt5 建立一個簡單的計算器, 其中會使用基本的 Python3 程式語法, 也必須了解 Python3 物件導向與視窗事件驅動程式的基本概念. 以下的網頁 Brython 程式架構, 因內容牽涉 Javascript 程式庫的導入與啟動, 僅提供練習 Python3 程式語法與參考用. 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第四週第一部分, 說明當版本資料變更時, 可以利用 fossil status 查看內容, 必要時利用 fossil delete 配合維護近端版本的一致性. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第四週第二部分, 說明如何利用 .fossil-settings 目錄下的 ignore-glob 檔案, 避開從近端推送到遠端的特定檔案. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第四週第一部分, 重複練習如何安排各學員近端的倉儲架構, 如何從範例倉儲複製資料. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第四週第二部分, 說明如何利用 Leo Editor 新增個人網誌. from 國立虎尾科技大學機械設計工程系 on Vimeo . 首先在網頁中置入可以練習基本 Python3 程式語法的環境, 採用的架構為 Brython 3.3.4 版, 可以在瀏覽器中將使用者的 Python3 程式轉為 Javascript 後執行. window.onload=function(){ brython({debug:1, pythonpath:['./../data/py']}); } 利用以下的編輯器執行 Python3 程式 在 Firefox 中, 以 Preferences - General - Downloads 選擇 \"Always ask me where to save files\" 在 Chrome 中, 以 Settings - Advanced - Downloads 選擇 Ask where to save each file before downloading function doSave(){ var blob = new Blob([localStorage[\"py_src\"]], {type: \"text/plain;charset=utf-8\"}); filename = document.getElementById('filename').value saveAs(blob, filename+\".py\"); } import sys import time import traceback import javascript from browser import document as doc, window, alert has_ace = True try: editor = window.ace.edit(\"editor\") session = editor.getSession() session.setMode(\"ace/mode/python\") editor.setOptions({ 'enableLiveAutocompletion': True, 'enableSnippets': True, 'highlightActiveLine': False, 'highlightSelectedWord': True }) except: from browser import html editor = html.TEXTAREA(rows=20, cols=70) doc[\"editor\"] <= editor def get_value(): return editor.value def set_value(x):editor.value = x editor.getValue = get_value editor.setValue = set_value has_ace = False if hasattr(window, 'localStorage'): from browser.local_storage import storage else: storage = None def reset_src(): if storage is not None and \"py_src\" in storage: editor.setValue(storage[\"py_src\"]) else: editor.setValue('for i in range(10):\\n\\tprint(i)') editor.scrollToRow(0) editor.gotoLine(0) def reset_src_area(): if storage and \"py_src\" in storage: editor.value = storage[\"py_src\"] else: editor.value = 'for i in range(10):\\n\\tprint(i)' class cOutput: def __init__(self,target): self.target = doc[target] def write(self,data): self.target.value += str(data) #if \"console\" in doc: sys.stdout = cOutput(\"console\") sys.stderr = cOutput(\"console\") def to_str(xx): return str(xx) info = sys.implementation.version doc['version'].text = 'Brython %s.%s.%s' % (info.major, info.minor, info.micro) output = '' def show_console(ev): doc[\"console\"].value = output doc[\"console\"].cols = 60 doc[\"console\"].rows = 10 # load a Python script def load_script(evt): _name = evt.target.value + '?foo=%s' % time.time() editor.setValue(open(_name).read()) # run a script, in global namespace if in_globals is True def run(*args): global output doc[\"console\"].value = '' src = editor.getValue() if storage is not None: storage[\"py_src\"] = src t0 = time.perf_counter() try: #ns = {'__name__':'__main__'} ns = {'__name__':'editor'} exec(src, ns) state = 1 except Exception as exc: traceback.print_exc(file=sys.stderr) state = 0 output = doc[\"console\"].value print('<completed in %6.2f ms>' % ((time.perf_counter() - t0) * 1000.0)) return state if has_ace: reset_src() else: reset_src_area() def clear_console(ev): doc[\"console\"].value = \"\" def clear_container(ev): doc[\"container\"].clear() doc['run'].bind('click',run) doc['show_console'].bind('click',show_console) doc['clear_console'].bind('click',clear_console) doc['clear_container'].bind('click',clear_container) Filename: .py Run Output 清除 清除畫布 from browser import document as doc import script1 def ex1(ev): script1.editor.setValue('''#ex1 簡單的 for 迴圈範例 for i in range(10): print(i) ''') script1.editor.scrollToRow(0) script1.editor.gotoLine(0) doc['ex1'].bind('click',ex1) ex1 -for 迴圈 from browser import document as doc import script1 def ex2(ev): script1.editor.setValue('''#溫度轉換程式 from browser import document as doc # 因為此函式與滑鼠互動, 需要 event 當作輸入 def convTemp(): mystring = \"\" cdegree = input(\"請輸入攝氏溫度:\") fdegree = float(cdegree)*9/5 + 32 output_string = \"攝氏 \" + str(cdegree) + \"度=華氏 \" + str(fdegree) + \"度\" # 利用 print() 將轉換結果送到 console 區 print(output_string) #直接呼叫 convTemp() 執行 convTemp() ''') script1.editor.scrollToRow(0) script1.editor.gotoLine(0) doc['ex2'].bind('click',ex2) ex2 -溫度換算 from browser import document as doc import script1 def ex3(ev): script1.editor.setValue('''#jansen 多連桿機構驗算 from math import pi, cos, sin, sqrt, acos radian = 180/pi degree = pi/180 #PLAP def plap(ax, ay, ac, bac, bx, by, ccw): if ccw == 1: cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay else: cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay return cx, cy #PLLP def pllp(ax, ay, ac, cb, bx, by, cw): if cw == 1: cx = -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) cy = (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) else: cx = -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) cy = (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) return cx, cy ax = -38 ay = 0 # b 為原點 bx = 0 by = 0 cx = 0 cy = 7.8 # m 為配合 PLAP 新增固定點 mx = 30 my = 7.8 # dcm ccw 方向角度 dcm = 30*degree cd = 15 # 三角形 dcm 為 ccw plap d=(a, cd, dcm, m) dx, dy = plap(cx, cy, cd, dcm, mx, my, ccw=1) print(\"dx=\", dx, \"dy=\", dy) # 三角形 aed 為 cw pllp e=(a, ae, ed, d) ae = 41.5 ed = 50 ex, ey = pllp(ax, ay, ae, ed, dx, dy, cw=1) print(\"ex=\", ex, \"ey=\", ey) # 三角形 afe 為 cw pllp f=(a, af, fe, e) af = 40.1 fe = 55.8 fx, fy = pllp(ax, ay, af, fe, ex, ey, cw=1) print(\"fx=\", fx, \"fy=\", fy) # 三角形 dha 為 cw pllp h=(d, dh, ha, a) dh = 61.9 ha = 39.3 hx, hy = pllp(dx, dy, dh, ha, ax, ay, cw=1) print(\"hx=\", hx, \"hy=\", hy) # 三角形 hgf 為 cw pllp g=(h, hg, gf, f) hg = 36.7 gf = 39.4 gx, gy = pllp(hx, hy, hg, gf, fx, fy, cw=1) print(\"gx=\", gx, \"gy=\", gy) # 三角形 hkg 為 cw pllp k=(h, hk, kg, g) hk = 49 kg = 65.7 kx, ky = pllp(hx, hy, hk, kg, gx, gy, cw=1) print(\"kx=\", kx, \"ky=\", ky) ''') script1.editor.scrollToRow(0) script1.editor.gotoLine(0) doc['ex3'].bind('click',ex3) ex3 -多連桿機構 from browser import document as doc import script1 def ex4(ev): script1.editor.setValue('''#ex4 turtle 網際繪圖 import turtle t=turtle.Turtle() t.penup() t.left(45) t.backward(125) t.right(45) t.pendown() for c in ['red', 'green', 'yellow', 'blue']: t.color(c) t.forward(75) t.left(90) t1=turtle.Turtle(\"turtle\") t1.penup() t1.pendown() t1.width(3) for c in ['red', 'blue', 'yellow', 'green', 'purple', 'brown']: t1.color(c) t1.forward(50) t1.left(60) t1.penup() t1.left(60) t1.backward(120) t1.pendown() t1.color('red') t1.write(\"I love Brython!!\") turtle._Screen().end() ''') script1.editor.scrollToRow(0) script1.editor.gotoLine(0) doc['ex4'].bind('click',ex4) ex4 -turtle 網際繪圖 from browser import document import script1 def get_file(e): data = open(\"./../python_ex/for1.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"get\"].bind(\"click\", get_file) from browser import document import script1 def get_temp1(e): data = open(\"./../python_ex/temp1.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"get_temp1\"].bind(\"click\", get_temp1) from browser import document import script1 def get_ver_and_kw(e): data = open(\"./../python_ex/ver_and_kw.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"get_ver_and_kw\"].bind(\"click\", get_ver_and_kw) from browser import document import script1 def jansen(e): data = open(\"./../python_ex/jansen.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"jansen\"].bind(\"click\", jansen) from browser import document import script1 def tutorial(e): # 利用 e.target.text 取的對應按鈕的字串, 可以開啟對應的程式檔案 data = open(\"./../python_ex/python3_\"+e.target.text+\".py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"tutorial1\"].bind(\"click\", tutorial) document[\"tutorial2\"].bind(\"click\", tutorial) document[\"tutorial3\"].bind(\"click\", tutorial) document[\"tutorial4\"].bind(\"click\", tutorial) document[\"tutorial5\"].bind(\"click\", tutorial) document[\"tutorial6\"].bind(\"click\", tutorial) document[\"tutorial7\"].bind(\"click\", tutorial) for1.py temp1.py ver_and_kw.py jansen.py tutorial1 tutorial2 tutorial3 tutorial4 tutorial5 tutorial6 tutorial7 Jansen 多連桿機構尺寸圖:","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-cadp-w4.html"},{"title":"2017 Fall CADP 第三週 - Fossil SCM & 網誌及投影片","text":"截至本週, 各學員的 Fossil SCM 倉儲已經可以透過 Wiki 儲存各週數位筆記, 並利用 Files 中的 Pelican Blog 與 Reveal.js 投影片架構, 提供各週詳細的學習報告. 使用 Fossil SCM 管理各學員的網誌與投影片的目的, 在建立往後進行協同設計所需的基本架構. 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 利用網路上既有的 stl 檔案輸入 V-rep 後, 加入鋼球, 模擬鋼球順著軌道運動情形. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二乙第三週第一部分, 說明 fossil clone 與 fossil open 用法, 以及如何利用 Leo Editor 在近端查驗網誌與投影片. from 國立虎尾科技大學機械設計工程系 on Vimeo . 設計組態管理 組態 (Configuration) 為組成內容與狀態的配置, 因此軟體組態管理 (SCM, Software Configuration Management) 就是針對軟體開發過程, 有關組成內容與狀態配置的管理. 由於機械設計主要在表達其固體、流體與軟體元件間的互動配置, 且可交付內容包含口語、文字、2D、3D、數學與實體表達資料, 因此機械設計流程中採用組態管理系統的目的, 就是希望參與機械設計的所有成員, 利用組態管理工具, 有效管理設計過程中所衍生的各種資料內容與配置, 並完整呈現各設計階段的歷程與狀態, 以方便追蹤設計變更並據以持續改進. 學習要點: 如何維護 Fossil SCM Wiki 內容 如何 clone 倉儲, 如何 open 倉儲 如何在近端利用 Leo Editor 維護並檢視網誌及投影片 如何利用網際投影片呈現六種表達資料 如何利用網誌呈現六種表達資料 Solvespace Nutcracker 零組件繪圖 學習如何在工作平面中繪製 2D 機構模擬圖 學習如何在不同工作面中, 繪製 2D 輪廓, 進行實體長出或除料 學習如何切換繪圖群組 (Group), 修改各階段繪圖內容, 完成所需的零組件 學習如何繪製旋轉長出實體 學習如何建立新的工作平面 學習如何利用點線面約束, 將實體零組件與 2D 機構模擬圖結合, 完成平面連桿機構運動模擬, 並輸出特定點的運動軌跡","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-cadp-w3.html"},{"title":"2017 Fall CP 第三週 - 視窗命令列與 Fossil SCM 常用指令","text":"首先要介紹基本的視窗命令提示指令 (Command Prompt Commands), 接著說明如何 clone 帶有網誌與投影片架構檔案的倉儲, 並且複製到各學員的倉儲後, 提交推送到遠端倉儲伺服器. 國立虎尾科技大學機械設計工程系計算機程式 - Win 10 建議安裝工具與下載可攜程式環境 from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一乙第三週第一部分, 說明如何從 https://cadpb.kmol.info/4052 clone 網誌與投影片架構檔案, 然後提交推送到自己的倉儲. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第三週第一部分, 說明如何準備各學員在 cpa.kmol.info 主機上的倉儲環境. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第三週第二部分, 說明如何利用 Leo Editor 管理 blog 與 reveal.js 投影片. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系計算機程式 - 一甲第三週第三部分, 修正第二部分送錯主機的操作流程, 完成 blog 在 Leo Editor 的改版, 並將新版本以遠端格式新增提交推送到遠端倉儲. from 國立虎尾科技大學機械設計工程系 on Vimeo . 命令提示指令視窗 開啟視窗操作系統中的命令提示指令視窗時, > 符號左側將顯示目前所處的磁碟代號區, 以及所在的目錄, 例如: C:\\> 表示目前位於 C: 的 \\ 目錄, 而 C: 表示代號為 C 的磁碟槽, 而 \\ 就是根目錄. 若是: C:\\tmp\\fossil\\wd\\4062> 表示目前位於 C: 的 \\tmp\\fossil\\wd\\4062 目錄. 若要回到 C: 的根目錄： C:\\tmp\\fossil\\wd\\4062>cd \\ C:\\> 若要在 C:\\ 目錄下建立 4062 目錄，然後更換目錄 (cd 或 chdir) 到 4062: C:\\>mkdir 4062 C:\\>cd 4062 C:\\4062> 若要連續跳往上一層目錄： C:\\tmp\\fossil\\wd\\4062>cd .. C:\\tmp\\fossil\\wd>cd .. C:\\tmp\\fossil> Cd chdir 指令的縮寫指令, change directory 更換目錄 Chdir change directory 更換目錄 Cls clear screen 刷新螢幕 Del delete files 刪除檔案 Dir display current directory content 列出目錄內容 Echo 回傳字串內容 Edit 編輯檔案 Exit 退出命令提示列 Ipconfig 列出 Internet Protocol 設定內容 Md make directory 的縮寫命令 Mkdir make directory 建立目錄 Move 移動檔案 Net 顯示或設定網路相關內容 Netstat 列出使用中的網路連線 Nslookup name server lookup Path 列出或設定指令搜尋路徑 Ping 向其他電腦送出 Internet Control Message Protocol (ICMP) Echo Request Rd remove directory 移除目錄縮寫指令 Ren rename 更改檔案名稱 Rmdir remove directory Set 顯示或設定環境變數 Start 執行命令同時開啟另一命令列視窗 Subst ｓｕｂｓｔｉｔｕｔｅ 以磁碟代號對應某一目錄 Taskkill 終止特定命令執行 Tracert sends Internet Control Message Protocol (ICMP) Echo Request messages to a specified remote computer with increasing Time to Live (TTL) field values and displays the IP address and hostname, if available, of the router interfaces between the source and destination. clone cpb 主機上的 4062 倉儲 甲班的 fossil scm 主機符號名稱為 cpa.kmol.info 而乙班則為 cpb.kmol.info, 接下來要將遠端 cpb.kmol.info 主機上的 4062 倉儲複製到近端, 因為主要是取得 4062 倉儲的內容, 而非事後要修改版本內容, 因此 clone 時不綁定帳號: Y:\\tmp\\fossil>fossil clone https://cpb.kmol.info/4062 4062.fossil 接下來建立一個 wd (working directory, 工作目錄) 目錄, 之後會將各倉儲壓縮檔解開到 wd 目錄下, 並且每個倉儲各自解開到, 以倉儲名稱命名的目錄區, 以便區別. 接著在 wd 目錄下, 再建立 4062 目錄, 更換目錄到 4062 目錄之後, 再以 fossil open 開啟倉儲內容至 4062 目錄中. Y:\\tmp\\fossil>mkdir wd Y:\\tmp\\fossil>cd wd Y:\\tmp\\fossil\\wd>mkdir 4062 Y:\\tmp\\fossil\\wd\\4062>fossil open ./../../4062.fossil clone 學員倉儲時綁定帳號 接下來要利用 fossil clone 複製遠端各學員的倉儲, 但在 clone 時就綁定帳號, clone 結束後將在 wd 目錄下建立與倉儲名稱相同的目錄, 並再用 fossil open 將倉儲開啟在工作目錄中．假設學員學號為 406123 Y:\\tmp\\fossil>fossil clone https://406123@cpb.kmol.info/406123 406123.fossil password for 406123: Y:\\tmp\\fossil>cd wd Y:\\tmp\\fossil\\wd>mkdir 406123 Y:\\tmp\\fossil\\wd\\406123>fossil open ./../../406123.fossil 接下來就可以將 4062 倉儲中解開的內容, 除了 FOSSIL 與 pycache 兩個目錄不要複製外, 其餘包含網誌與投影片架構的檔案放入各學員開啟後的倉儲目錄中, 然後新增所有檔案, 並且提交後自動推回遠端, 同時近端的 406123.fossil 也將與遠端及工作目錄中的內容保持同步. Y:\\tmp\\fossil\\wd\\406123>fossil add . Y:\\tmp\\fossil\\wd\\406123>fossil commit -m \"add blog and reveal files\" clone 學員倉儲時未綁定帳號 假如在 fossil clone 時未能綁定帳號, 則隨後的新增與提交無法自動推送, 必須指定用戶帳號, 以手動推送. Y:\\tmp\\fossil>fossil clone https://cpb.kmol.info/406123 406123.fossil password for 406123: Y:\\tmp\\fossil>cd wd Y:\\tmp\\fossil\\wd>mkdir 406123 Y:\\tmp\\fossil\\wd\\406123>fossil open ./../../406123.fossil 複製 4062 倉儲內容時, 記得不要複製 FOSSIL 與 pycache 兩個目錄．接著就可以新增並且提交, 但 fossil 會顯示自動推送失敗, 因為之前 fossil clone 時沒有綁定帳號. 新增提交後必須手動推送. Y:\\tmp\\fossil\\wd\\406123>fossil add . Y:\\tmp\\fossil\\wd\\406123>fossil commit -m \"add blog and reveal files\" Y:\\tmp\\fossil\\wd\\406123>fossil push https://406123@cpb.kmol.info/406123 完成將 blog 與 reveal 投影片送到 cpb.kmol.info 後, 可以透過各學員倉儲下的 /doc/trunk/index.html 檢視最新版投影片, 從 /doc/trunk/blog/index.html 檢視最新版的網誌. 若要查看舊版的資料, 可以將 trunk 換成版次號碼. https://cpb.kmol.info/4062/doc/trunk/blog/index.html 就是 4062 倉儲最新版網誌, 而 https://cpb.kmol.info/4062/doc/efd9e81386f5ff32/blog/index.html 就是版本號碼為 efd9e81386f5ff32 的舊版本網誌.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-cp-w3.html"},{"title":"2017 Fall CADP 第二週 - 區網 Fossil 倉儲","text":"本學期起各班透過一台 Ubuntu 16.04 主機, 建立 Fossil SCM 伺服器, 且每一學員發放一個 Fossil SCM 倉儲, 其中各學員可以利用 Wiki 與 Technote 紀錄學習資料外, 還可以將靜態網誌與簡報檔案放入 Files 資料區. 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 第二週開始, 在區域網路上提供每一學員一個 Fossil SCM 倉儲檔案, 可以在隨後上課即時存放數位筆記與電腦輔助機械設計專案執行相關檔案. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二乙第二週上課內容, 主要說明如何設定各學員在 https://cadpb.kmol.info 主機上的 Fossil SCM 倉儲, 以便進行機械設計組態管理之用. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二乙第二週上課內容之二, 說明如何 fossil clone 自己的倉儲到近端, 然後利用 fossil open 開啟在近端工作目錄下, 準備接續隨後的改版與提交推送. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 二乙第二週上課內容之三, 說明如何從 https://cadpb.kmol.info 以 fossil clone 取下資料, 放入用戶倉儲, 然後提交推送到各自的倉儲. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 展示在 Solvespace 繪製圓形軌道, 轉為 STL 格式後輸入 V-rep , 並以 Python3 程式進行運動模擬. from 國立虎尾科技大學機械設計工程系 on Vimeo . 各班倉儲主機 各班學員在下列主機中, 以學號作為倉儲名稱. 一甲: https://cpa.kmol.info 一乙: https://cpb.kmol.info 二甲: https://cadpa.kmol.info 二乙: https://cadpb.kmol.info 倉儲建立流程 為每位學員建立倉儲的設想流程如下: 各學員可以獨立維護倉儲內容, 也可以在總管理員的權限下, 為分組學員建立帳號, 逐步導入協同設計 各學員的倉儲以修課班級命名伺服器, 以學號命名倉儲, 方便依照此一規律擷取各學員的倉儲頁面. 各學員能以電子郵件收到與新建倉儲相關的連結, 以及帳號密碼. 必須擴增 Ubuntu ulimits -n 同時開檔的設限範圍 (內定只允許同時開啟 1024 個檔案) 解決方案: 主機名稱可以透過 domain dns 中的 CNAME 別名方式處理, 因為目前所能提供出來的 IPv4/IPv6 雙支援主機, 之前已經都設定了符號名稱. fossil init 雖然提供指定管理者的 -A 選項功能, 但是無法直接指定管理者對應密碼, 因此必須建立倉儲之後, 再利用 fossil user 修改密碼, 之後再利用 Gmail 寄出通知信, 其中提供倉儲連結, 登入帳號與密碼等資訊. 建立各學員倉儲檔案的程式如下, 如前所述, 主要透過兩個 Fossil SCM 指令完成, 在 Windows 採用 Fossil SCM 2.3 版建立所有 .fossil 倉儲時, 將同時以 email 通知各學員. 各學員的 .fossil 檔案再以 sftp 送到伺服主機對應帳號所屬的目錄下. 必須要特別注意的是, 採用 Fossil SCM 2.3 版所建立的 .fossil 倉儲檔案, 在 Ubuntu 操作系統上也必須採用相同版本的 fossil, 否則舊版 fossil 可能無法開啟新版 fossil 程式所建立的倉儲檔. import os import string import random # 使用 Gmail 寄信必須導入下列模組 import smtplib import re from email.mime.text import MIMEText from email.header import Header # 用來以亂數建立密碼的函式 def id_generator(size=6, chars=string.ascii_uppercase + string.digits): ''' source: https://stackoverflow.com/questions/2257441/random-string-generation-with-upper-case-letters-and-digits-in-python ''' return ''.join(random.choice(chars) for _ in range(size)) # 讀取學員名單, 逐一取得學員學號, 學員名單, 檢查點 1/7 student_data = open(\"2017fall_list/1b.txt\").read() student_list = student_data.splitlines() # 利用 gmail smtp 功能寄信 server = smtplib.SMTP('smtp.gmail.com:587') server.ehlo() server.starttls() # 以下必須準備好對應郵件帳號與密碼的外部檔案, 所提供的寄信帳號, 是否可以寄信, 檢查點 2/7 ''' 寄信之前必須到 https://www.google.com/settings/security/lesssecureapps 修改權限, 改為較低安全權限 否則無法使用程式寄信! ''' # 從外部檔案讀取要用來寄信的 gmail 帳號與密碼 # mail.txt 格式為: 電子郵箱,對應密碼, 以逗點隔開, 檢查點 3/7 email_data = open(\"z:/2017fall/mail.txt\").read() email, email_password= email_data.split(\",\") print(email, email_password) # 是否登入所提供寄信的電子郵箱, 4/7 server.login(email, email_password) # 不同課程名稱, 與對應主機名稱, 必須配合修改 5/7 course_title = \"計算機程式\" fossil_server = \"cpb.kmol.info\" for student_num in student_list: username = student_num repository = username + '.fossil' # 利用所提供的字串, 以亂數組成六個字元的密碼 password = id_generator(6, \"23456789abcdef\") print(student_num, \", \" , password) # 執行 dos command 指令, 建立倉儲 os.system(\"fossil init -A \" +username + \" \" + repository) print(\"已經建立倉儲 \" + repository) # 執行 dos command 指令, 修改使用者密碼 os.system(\"fossil user password \" + username + \" \" + password + \" -R \" + repository) print(\"已經修改密碼\") # 利用 Gmail 寄信, 告知各學員倉儲連結與帳號密碼 # 每一位學員收到的 output 都從這裡 reset output = \"\" # 若學號欄為空, 則不寄信 if student_num != \"\": # output 為寄給每一位學員的資料表格 mail_content = student_num+' 您好: 您在 '+course_title+' 課程中的區域網路倉儲: https://'+fossil_server+'/'+student_num+' ' mail_content += '管理帳號為:'+ student_num + ' 管理密碼為: '+ password+' ' print(student_num) print(mail_content) # 至此 mail_content 已經確定 # 在測試與實際寄送資料, 也必須配合修改, 檢查點 6/7 receiver_email = student_num + \"@gm.nfu.edu.tw\" # 測試用 #receiver_email = student_num+\"@mde.tw\" # 列出收信人 email 位址 #print(receiver_email) #message= MIMEText(mail_content,'plain','UTF-8') # 以 html 格式寄信 message= MIMEText(mail_content,'html','UTF-8') message['Subject'] = Header(course_title+\" Fossil SCM 帳號通知\", 'UTF-8') # 可以先不寄信, 確定格式正確後再開啟, 是否實際寄出信件, 檢查點 7/7 server.sendmail(\"gmail_address\", receiver_email, message.as_string()) server.quit() 各班所完成的主機: 二甲電腦輔助設計實習: https://cadpa.kmol.info 二乙電腦輔助設計實習: https://cadpb.kmol.info 一甲計算機程式: https://cpa.kmol.info 一乙計算機程式: https://cpb.kmol.info 各學員練習項目 登入後修改密碼 進入 Admin - Configuration 將倉儲 Project Name 設為自己的學號 建立一個與 Project Name 相同的 Wiki 頁面, 作為 Home 首頁 練習建立一個 .mp4 操作影片檔, 以 attach 方式附加在 Wiki 首頁 進入 Admin - Timeline 將倉儲的時區設為台灣時區 以 fossil clone https://帳號@cadpa.kmol.info/學號 學號.fossil 在近端建立倉儲 以 fossil open 將學號.fossil 開啟在工作目錄, 以便改版 改版後以 fossil add . 以及 fossil commit -m \"提交訊息\" 進行改版資料的提交推送 從 https://cadpa.kmol.info/4052 clone 內容到近端後, 開啟資料並將 blog 與投影片架構複製到自己的倉儲中 確認會新增 blog 與投影片內容後, 將改版資料提交推送到遠端 投影片最新版連結為 /doc/trunk/index.html (例如: 4052 投影片 ) blog 最新版連結則為 /doc/trunk/blog/index.html (例如: 4052 網誌 )","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-cadp-w2.html"},{"title":"2017 Fall CADP 第一週 - 分組與實習專案規劃","text":"電腦輔助設計實習第一週課程內容. 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - Nutcracker 曲柄滑塊機構在 Solvespace 完成繪圖後, 以 STL 格式轉入 V-rep 進行運動模擬. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 說明如何利用 Fossil 指令中的 fossil init 建立倉儲, 如何在區域網路中透過 Stunnel 提供 https 連線, 如何在近端利用 fossil ui 以網際介面維護內容. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 第二週開始, 在區域網路上提供每一學員一個 Fossil SCM 倉儲檔案, 可以在隨後上課即時存放數位筆記與電腦輔助機械設計專案執行相關檔案. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 說明如何將遠端的 Fossil SCM 倉儲 clone 到近端後, 以 open 指令開啟在工作目錄之後, 就可以再利用 add 與 commit, 改版倉儲內容。 from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 說明如何開啟 Leo Editor, 如何開啟 blog 與投影片專案檔案, 包括如何利用近端與遠端格式網誌轉檔. from 國立虎尾科技大學機械設計工程系 on Vimeo . 國立虎尾科技大學機械設計工程系電腦輔助設計實習 - 說明如何在 Solvespace 建立零組件, 轉進 V-rep 後, 針對各零件設定模擬屬性後, 可以進行特定的系統動態模擬. from 國立虎尾科技大學機械設計工程系 on Vimeo . 座位與分組 由左至右, 按照學號順序入座, 前三後三每六位一組, 每三組分為一大組, 分組目的在練習協同設計, 各組員必須親自練習所有課程內容, 並且每週自行舉證出席狀況, 問答狀況與操作練習狀況. 每班提供一台系主幹網路伺服器, 用來放置各學員的 Fossil SCM 倉儲練習影片與上課心得資料, 最後各學員 Fossil SCM 倉儲將會與 Github 倉儲進行資料同步, 以便下學期能在 Fossil SCM 與 Github 平台上進行協同產品設計. 期中考前主要為 Nutcracker 零組件 Solvespace 與 Onshape 繪圖與 V-rep 模擬, 期中考後則納入 Arduino 伺服馬達控制與專案零組件設計與 3D 列印製作. 電腦輔助設計實習專案 2017 年 Fall 電腦輔助設計實習的專題題目為\"機電資整合鋼球運動系統\" (infomechatronic linkage marble machine), 範例機電系統可參考: 機電資整合鋼球運動系統設計要求 其中, 連桿機構零組件 必須採用 Solvespace 與 Onshape 繪製, 機構與鋼球運動模擬必須採用 V-rep 進行, 控制 V-rep 模擬系統的外部程式套件, 必須採用 Python3 remote API 架構完成, 電子電機系統必須採用 AutoDesk TinkerCAD 模擬, 用來記錄鋼球通過關鍵點次數, 以及鋼球運動總距離及總爬升高度的資訊系統, 則必須採用 Python3 以及 PyQt5 建置, 而主要機構零組件可以採 3D 印表機列印 . 各組所完成的\"機電資整合鋼球運動系統\", 必須包含一個主要的鋼球運送機構模組 (以下稱為主模組), 並且能夠納入各學員所完成的軌道機構模組 (以下稱為軌道模組), 進行循環運動, 且 整體系統的尺寸必須能夠放入郵局 Box2 紙箱 中(規格: 23×18×19(cm) . 當各組開始啟動\"機電資整合鋼球運動系統\"專題製作時, 各學員必須將所有細節紀錄在 二甲 與 二乙 所分配到的 Fossil SCM 伺服器主機中, 且各學員在近端隨身碟必須自行保全所有與專題相關的資料, 專題完成後, 再將各學員的 Fossil SCM 倉儲同步到 Github 倉儲. 各班依照座位, 前後三人共六人為一小組, 必須完成一套主模組設計, 各學員則分別提供一組軌道模組配合, 進行循環運動模擬. 期中考之後則每三小組成一大組, 根據學員投票決定 實作一組主模組, 各學員則必須實作一組軌道系統與主模組配合運作 . 了解可攜程式系統架構與用法 start.bat 啟動, stop.bat 關閉, SciTE 可以執行 .py 與 .c 程式, SciTE 開啟 y:\\launchLeo.py 執行後, 可以開啟 Leo Editor, Leo Editor 主要用來建立 Pelican 網誌與 Reveal.js 簡報投影片, 還可存放相關操作關鍵內容或其他參考資料. 在 dos 命令視窗執行 eric6, 可以開啟 Eric6 IDE 環境, 可以用來開發 PyQt5 視窗程式, 可以與 V-rep 機構模擬整合使用, 加上實體機電系統, 達到機電資電腦輔助設計與製造的專案實習. 了解 Fossil SCM 用法 fossil init 建立倉儲 fossil ui 了解網際功能 了解 Solvespace 零組件繪圖 Solvespace 為一套小型的參數式 CAD 套件, 為 GPL 授權程式, Onshape 則為全雲端參數式 CAD 系統, 目前提供免費教育帳號使用. Solvespace Sketch in new workplane 的用法 Solvespace Properties browser 的用法 Solvespace Constraint distance, diameter, length 的用法 Solvespace Constraint point on line, curve, plane, point 的用法 Solvespace Constraint to be parallel or tangent 的用法","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-cadp-w1.html"},{"title":"2017 Fall CP 第一週 - 分組與可攜環境","text":"計算機程式第一週課程內容. 國立虎尾科技大學機械設計工程系計算機程式 - 從 mde.tw 進入後可以在近端、區網檢視與課程相關的內容, 其中包含如何啟動可攜系統, 如何執行 .py 程式, 如何編譯執行 .c 程式等. from 國立虎尾科技大學機械設計工程系 on Vimeo . 課堂通知 一乙自下週起連續三週, 各多上一堂課, 以補 10/9 的彈性放假. 下週起, 每位同學都要準備 3.0 規格以上的 USB 隨身碟, 32 GB 或以上容量, 100 頁 B5 大小的筆記本, 還有耳機. USB 隨身碟用來存放可攜系統與每週在近端倉儲改版內容與操作影片 mp4 檔案. 本課程的操作影片拍攝建議使用 https://getsharex.com/ 筆記本用來詳細記錄各種操作細節, 而耳機則用來觀看課程教學影片用. 課堂練習 點擊 start.bat 啟動隨身系統, 在 SCiTE 編輯器中練習執行 calculator.py 與 helloworld.c calculator.py 可以利用 PyQt5 example calculator 關鍵字搜尋, 而 ANSI (American National Standard Institute) C 則可以透過 ANSI C hello world 關鍵字搜尋. 了解如何執行 Python3 與 ANSI 程式之後, 請利用 Google 搜尋 Fossil SCM 的相關介紹, 並且回想一下: 何謂機械設計? 所謂機械設計, 就是透過詳細思慮考量, 完成包括固體、流體與軟體等互動元件間之精巧配置, 使其展現特定功能之具體規劃表達. 工程師有那六種表達方式? 口語, 文字, 2D, 3D, 數學理論與實作表達. 創造力的三個基本要素: 自學力, 執行力與想像力. 自學力在提升自我解題能力, 執行力則在運用所學解決問題, 當累積一定經驗後, 就能透過想像、自學與執行過程之整合運用, 創造出具效能的創新產品. 接下來將要練習如何開啟 Leo Editor, 開啟 Leo Editor 專案, 如何使用 Fossil SCM 與 Eric6 IDE, 請大家要仔細筆記, 並且透過實際操作, 了解各種系統的特性與用法. Leo Editor 開啟與編輯 Reveal.js 投影片 編輯 Pelican 靜態 blog 利用 IPv4 WWW 伺服器在近端檢視 Pellican Blog Pelican Blog 有哪些功能? Reveal.js 有哪些功能? 當您熟悉如何利用 Leo Editor 建立簡報與網誌之後, 就是準備以 Fossil SCM 來管理這些文字系統了. Fossil SCM fossil init 倉儲名稱.fossil fossil ui fossil open fossil clone fossil add . fossil commit -m --no-warnings fossil update 請仔細回想上述每一個操作細節的特性, 我們終於要使用 Eric6 IDE 學習 Python3 計算機程式了. 課程網誌加入 disqus 留言區 目前使用的是 https://disqus.com/ 所提供的免費留言區, 以 https://kmolab.github.io/blog 與 https://mde1a1.kmol.info/2017fall/doc/trunk/blog 為例, 採用 course At mde dot tw 專用帳號登記, 並且在 trusted domains 將 kmolab.github.io 與 mde1a1.kmol.info 納入, 就可以讓一個留言區, 在不同的網誌中使用. 當 Pelican Blog 內容中的 tipuesearch_content.js 過長時, Fossil SCM 在提交推送時會發出 \"Abandoning commit due to long lines in tipuesearch_content.js 的錯誤, 而中止推送. 因此在提交 Pelican Blog 時, 必須使用: fossil commit -m \"your commit message\" --no-warnings 同時, 在使用 theme/pelican-bootstrap3 轉換遠端網誌加入 disqus 留言區時, 必須要注意 plugin/tipue_search/ tipue_search.py 中必須配合建立 tipuesearch_content.json, 目的在可以根據關鍵字建立搜尋資料檔. 總結上述, 利用近端按鈕建立網誌的目的, 在讓使用者可以直接在近端檢查內容. 利用遠端按鈕建立網誌的目的, 則在加入對應的 disqus 留言區.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-cp-w1.html"},{"title":"2017 Fall 各班課程日期","text":"利用 Brython 程式列印各班課程日期. window.onload=function(){ brython({debug:1, pythonpath:['./../data/py']}); } 列出 2017 Fall 各班課程日期: from browser import document, html import calendar import locale import math cal2 = document[\"cal2\"] def getClassdate(year=2017, startM=9, startD=11, w=0, note=\"\"): # w=0 表示課程排在星期一 # startM 表示開學月份, startD 表示開學日 # note 為課程初始告示 # default calendar MONDAY is the first day of the week # 每學期共有 18 週, 下學期必須處理跨年 # 準備納入放假日檢查與列印 totalW = 18 count = 0 # output = \"2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: \" output = note + html.BR() # 若必須全年搜尋則 7 改為 12, 但是因為只有 18 週, 因此邏輯要修改讓程式較快結束 for month in range(startM, 13): monthArray = calendar.monthcalendar(year, month) for week in range(len(monthArray)): weekArray = monthArray[week] # 只需要列出星期 (w+1) # 不計第零週 if weekArray[w] != 0: if month == startM: if weekArray[w] >= startD: count += 1 if count <= totalW: if (month == 10 and weekArray[w] == 9) or (month == 11 and weekArray[w] == 24): output += \"w\"+str(count)+\"-\"+ str(month)+ \"/\" + str(weekArray[w]) + \"(放假), \" else: output += \"w\"+str(count)+\"-\"+ str(month)+ \"/\" + str(weekArray[w]) + \", \" else: count += 1 if count <= totalW: if (month == 10 and weekArray[w] == 9) or (month == 11 and weekArray[w] == 24): output += \"w\"+str(count)+\"-\"+ str(month)+ \"/\" + str(weekArray[w]) + \"(放假), \" else: output += \"w\"+str(count)+\"-\"+ str(month)+ \"/\" + str(weekArray[w]) + \", \" # 若列印週數不足, 則需跨年 if totalW > count: for month in range(1, math.ceil((totalW-count)/4)+1): monthArray = calendar.monthcalendar(year+1, month) for week in range(len(monthArray)): weekArray = monthArray[week] # 只需要列出星期 (w+1) # 不計第零週 if weekArray[w] != 0: count += 1 if count <= totalW: if month == 1 and weekArray[w] == 1: output += \"w\"+str(count)+\"-\"+ str(month)+ \"/\" + str(weekArray[w]) + \"(放假), \" else: output += \"w\"+str(count)+\"-\"+ str(month)+ \"/\" + str(weekArray[w]) + \", \" cal2 <= output # 1b 計算機程式 (一 w=0) getClassdate(year=2017, startM=9, startD=11, w=0, note=\"2017 Fall 1bCP (一) 13:20-16:10 各週上課日期: \") cal2 <= html.BR() + html.BR() # 1a 計算機程式 (四 w=3) getClassdate(year=2017, startM=9, startD=11, w=3, note=\"2017 Fall 1aCP (四) 08:10-12:00 各週上課日期: \") cal2 <= html.BR() + html.BR() # 2a 電腦輔助設計實習 (四 w=3) getClassdate(year=2017, startM=9, startD=11, w=3, note=\"2017 Fall 2aCADP (四) 13:20-16:10 各週上課日期: \") cal2 <= html.BR() + html.BR() # 2b 電腦輔助設計實習 (五 w=4) getClassdate(year=2017, startM=9, startD=11, w=4, note=\"2017 Fall 2bCADP (五) 13:20-16:10 各週上課日期: \") cal2 <= html.BR() + html.BR()","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017-fall-courses-date.html"},{"title":"網際 Brython 3.3.1 程式執行環境","text":"Brython 程式環境可以用來練習許多 Python3 的簡單語法, 也可以納入 Javascript 程式庫, 利用 Ajax 模式結合網際瀏覽器與伺服器上的資源解決協同產品設計流程上的問題. window.onload=function(){ brython({debug:1, pythonpath:['./../data/py']}); } 列出 2017 Spring 協同產品設計實習課程日期之 Python 程式碼如下: from browser import document, html import calendar import locale cal2 = document[\"cal2\"] def getClassdate(year=2017, startM=2, startD=20, w=0, note=\"\"): # w=0 表示課程排在星期一 # startM 表示開學月份, startD 表示開學日 # note 為課程初始告示 # default calendar MONDAY is the first day of the week # 每學期共有 18 週 totalW = 18 count = 0 # output = \"2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: \" output = note + html.BR() # 若必須全年搜尋則 7 改為 12, 但是因為只有 18 週, 因此邏輯要修改讓程式較快結束 for month in range(startM, 7): monthArray = calendar.monthcalendar(2017, month) for week in range(len(monthArray)): weekArray = monthArray[week] # 只需要列出星期 (w+1) if weekArray[w] != 0: if month == startM: if weekArray[w] > startD: count += 1 if count <= totalW: if month == 3 and weekArray[w] == 31: output += \"w\"+str(count)+\"-\"+ str(month)+ \"/\" + str(weekArray[w]) + \"(放假), \" else: output += \"w\"+str(count)+\"-\"+ str(month)+ \"/\" + str(weekArray[w]) + \", \" else: count += 1 if count <= totalW: if month == 3 and weekArray[w] == 31: output += \"w\"+str(count)+\"-\"+ str(month)+ \"/\" + str(weekArray[w]) + \"(放假), \" else: output += \"w\"+str(count)+\"-\"+ str(month)+ \"/\" + str(weekArray[w]) + \", \" cal2 <= output # 2b 協同產品設計實習 (三 w=2) getClassdate(year=2017, startM=2, startD=20, w=2, note=\"2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: \") cal2 <= html.BR() + html.BR() # 2a 協同產品設計實習 (四 w=3) getClassdate(year=2017, startM=2, startD=20, w=3, note=\"2017 Spring 2aCD (四) 08:10-12:00 各週上課日期: \") cal2 <= html.BR() + html.BR() # 1a 網際內容管理 (五 w=4) getClassdate(year=2017, startM=2, startD=20, w=4, note=\"2017 Spring 1aWCM (五) 13:20-16:10 各週上課日期: \") cal2 <= html.BR() + html.BR() # VE1a 網際內容管理 (五 w=4) getClassdate(year=2017, startM=2, startD=20, w=4, note=\"2017 Spring VE1aCP (五) 18:30-20:00 各週上課日期: \") cal2 <= html.BR() + html.BR() 利用伺服器執行 Python3 程式 Jupyterhub: https://8888.kmol.info:9443 利用以下的編輯器執行 Python3 程式 在 Firefox 中, 以 Preferences - General - Downloads 選擇\"Always ask me where to save files\" 在 Chrome 中, 以 Settings - Advanced - Downloads 選擇 Ask where to save each file before downloading function doSave(){ var blob = new Blob([localStorage[\"py_src\"]], {type: \"text/plain;charset=utf-8\"}); filename = document.getElementById('filename').value saveAs(blob, filename+\".py\"); } import sys import time import traceback import javascript from browser import document as doc, window, alert has_ace = True try: editor = window.ace.edit(\"editor\") session = editor.getSession() session.setMode(\"ace/mode/python\") editor.setOptions({ 'enableLiveAutocompletion': True, 'enableSnippets': True, 'highlightActiveLine': False, 'highlightSelectedWord': True }) except: from browser import html editor = html.TEXTAREA(rows=20, cols=70) doc[\"editor\"] <= editor def get_value(): return editor.value def set_value(x):editor.value = x editor.getValue = get_value editor.setValue = set_value has_ace = False if hasattr(window, 'localStorage'): from browser.local_storage import storage else: storage = None def reset_src(): if storage is not None and \"py_src\" in storage: editor.setValue(storage[\"py_src\"]) else: editor.setValue('for i in range(10):\\n\\tprint(i)') editor.scrollToRow(0) editor.gotoLine(0) def reset_src_area(): if storage and \"py_src\" in storage: editor.value = storage[\"py_src\"] else: editor.value = 'for i in range(10):\\n\\tprint(i)' class cOutput: def __init__(self,target): self.target = doc[target] def write(self,data): self.target.value += str(data) #if \"console\" in doc: sys.stdout = cOutput(\"console\") sys.stderr = cOutput(\"console\") def to_str(xx): return str(xx) info = sys.implementation.version doc['version'].text = 'Brython %s.%s.%s' % (info.major, info.minor, info.micro) output = '' def show_console(ev): doc[\"console\"].value = output doc[\"console\"].cols = 60 doc[\"console\"].rows = 10 # load a Python script def load_script(evt): _name = evt.target.value + '?foo=%s' % time.time() editor.setValue(open(_name).read()) # run a script, in global namespace if in_globals is True def run(*args): global output doc[\"console\"].value = '' src = editor.getValue() if storage is not None: storage[\"py_src\"] = src t0 = time.perf_counter() try: #ns = {'__name__':'__main__'} ns = {'__name__':'editor'} exec(src, ns) state = 1 except Exception as exc: traceback.print_exc(file=sys.stderr) state = 0 output = doc[\"console\"].value print('<completed in %6.2f ms>' % ((time.perf_counter() - t0) * 1000.0)) return state if has_ace: reset_src() else: reset_src_area() def clear_console(ev): doc[\"console\"].value = \"\" doc['run'].bind('click',run) doc['show_console'].bind('click',show_console) doc['clear_console'].bind('click',clear_console) Filename: .py Run Output 清除 from browser import document as doc import script1 def ex1(ev): script1.editor.setValue('''#ex1 簡單的 for 迴圈範例 for i in range(10): print(i) ''') script1.editor.scrollToRow(0) script1.editor.gotoLine(0) doc['ex1'].bind('click',ex1) ex1 -for 迴圈 from browser import document as doc import script1 def ex2(ev): script1.editor.setValue('''#溫度轉換程式 from browser import document as doc # 因為此函式與滑鼠互動, 需要 event 當作輸入 def convTemp(): mystring = \"\" cdegree = input(\"請輸入攝氏溫度:\") fdegree = float(cdegree)*9/5 + 32 output_string = \"攝氏 \" + str(cdegree) + \"度=華氏 \" + str(fdegree) + \"度\" # 利用 print() 將轉換結果送到 console 區 print(output_string) #直接呼叫 convTemp() 執行 convTemp() ''') script1.editor.scrollToRow(0) script1.editor.gotoLine(0) doc['ex2'].bind('click',ex2) ex2 -溫度換算 from browser import document as doc import script1 def ex3(ev): script1.editor.setValue('''#jansen 多連桿機構驗算 from math import pi, cos, sin, sqrt, acos radian = 180/pi degree = pi/180 #PLAP def plap(ax, ay, ac, bac, bx, by, ccw): if ccw == 1: cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay else: cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay return cx, cy #PLLP def pllp(ax, ay, ac, cb, bx, by, cw): if cw == 1: cx = -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) cy = (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) else: cx = -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) cy = (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) return cx, cy ax = -38 ay = 0 # b 為原點 bx = 0 by = 0 cx = 0 cy = 7.8 # m 為配合 PLAP 新增固定點 mx = 30 my = 7.8 # dcm ccw 方向角度 dcm = 30*degree cd = 15 # 三角形 dcm 為 ccw plap d=(a, cd, dcm, m) dx, dy = plap(cx, cy, cd, dcm, mx, my, ccw=1) print(\"dx=\", dx, \"dy=\", dy) # 三角形 aed 為 cw pllp e=(a, ae, ed, d) ae = 41.5 ed = 50 ex, ey = pllp(ax, ay, ae, ed, dx, dy, cw=1) print(\"ex=\", ex, \"ey=\", ey) # 三角形 afe 為 cw pllp f=(a, af, fe, e) af = 40.1 fe = 55.8 fx, fy = pllp(ax, ay, af, fe, ex, ey, cw=1) print(\"fx=\", fx, \"fy=\", fy) # 三角形 dha 為 cw pllp h=(d, dh, ha, a) dh = 61.9 ha = 39.3 hx, hy = pllp(dx, dy, dh, ha, ax, ay, cw=1) print(\"hx=\", hx, \"hy=\", hy) # 三角形 hgf 為 cw pllp g=(h, hg, gf, f) hg = 36.7 gf = 39.4 gx, gy = pllp(hx, hy, hg, gf, fx, fy, cw=1) print(\"gx=\", gx, \"gy=\", gy) # 三角形 hkg 為 cw pllp k=(h, hk, kg, g) hk = 49 kg = 65.7 kx, ky = pllp(hx, hy, hk, kg, gx, gy, cw=1) print(\"kx=\", kx, \"ky=\", ky) ''') script1.editor.scrollToRow(0) script1.editor.gotoLine(0) doc['ex3'].bind('click',ex3) ex3 -多連桿機構 from browser import document import script1 def get_file(e): data = open(\"./../python_ex/for1.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"get\"].bind(\"click\", get_file) from browser import document import script1 def get_temp1(e): data = open(\"./../python_ex/temp1.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"get_temp1\"].bind(\"click\", get_temp1) from browser import document import script1 def get_ver_and_kw(e): data = open(\"./../python_ex/ver_and_kw.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"get_ver_and_kw\"].bind(\"click\", get_ver_and_kw) from browser import document import script1 def jansen(e): data = open(\"./../python_ex/jansen.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"jansen\"].bind(\"click\", jansen) for1.py temp1.py ver_and_kw.py jansen.py Jansen 多連桿機構尺寸圖:","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-brython-editor-331.html"},{"title":"Ubuntu 16.04 環境下啟動 Stunnel 與 Fossil SCM","text":"說明如何在 Ubuntu 操作系統中, 安裝並設定 Stunnel 後與 Fossil SCM server 結合啟動. Stunnel 與 Fossil SCM 安裝 sudo apt update sudo apt install stunnel4 -y sudo apt install fossil 環境變數與開機啟動設定 /etc/environment 設定: HTTPS=on /etc/default/stunnel4 檔案設定: ENABLED=1 Stunnel 設定並執行 fossil http 指令 stunnel.conf 建立 localhost.key 與 localhost.crt: sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt /etc/stunnel/stunnel.conf 設定檔案, 可同時支援 IPv4 與 IPv6 協定: [https] accept = your_IPv4_ip:443 accept = :::443 cert = /etc/stunnel/localhost.crt key = /etc/stunnel/localhost.key exec = /usr/bin/fossil execargs = /usr/bin/fossil http /home/user/repository/mde2a1.fossil --https --nojail 其中 --nojail 目的在 drop the root privilege but do not enter the chroot jail 重新啟動 stunnel4 則使用 /etc/init.d/stunnel4 restart 上述設定完成後, 重新開機即可以 https://yourip 連結至 mde2a1.fossil 網際管理介面.","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017spring-ubuntu-stunnel-fossil.html"},{"title":"Windows 環境下啟動 Stunnel 與 Fossil SCM","text":"說明如何在 Windows 操作系統中, 利用 batch 檔案取得電腦連外 IP, 並且設定 Stunnel 後與 Fossil SCM server 配合啟動. 以下使用 Spring 2017 1GB 版本的隨身程式系統, 修改 start.bat 如下後, 可以自動取得電腦連外 IPv4 IP 位址, 並將設定資料寫入 stunnel.conf 後啟動. REM tiny2017 主要針對初學 Python3 與 C 學員所建立 REM 近端使用 fossil 管理資料版本, 並且定時轉為 git 格式後上傳到 github @echo off REM 設定 y 硬碟代號與 data 目錄對應 set Disk=y subst %Disk%: \"data\" REM 設定 leo 相關對應 Home 位置 set HomePath=%Disk%:\\home set HomeDrive=%Disk%:\\home set Home=%Disk%:\\home REM 將系統 Python 程式的 io 設為 utf-8 set PYTHONIOENCODING=\"utf-8\" REM 將後續的指令執行, 以 %Disk% 為主 %Disk%: REM 設定 PYTHONPATH set PYTHONPATH=%Disk%:\\python-3.5.3-embed-amd64 REM 設定 Leo 所用的編輯器 set LEO_EDITOR=%Disk%:\\wscite\\SciTE.exe REM for fossil https 連線設定 set HTTPS=on REM 指令搜尋路徑設定 set path1=%PATH%;%Disk%:;%Disk%:\\python-3.5.3-embed-amd64;%Disk%:\\git\\bin;%Disk%:\\stunnel\\bin;%Disk%:\\sqlite-tools;%Disk%:\\python-3.5.3-embed-amd64\\Scripts;%Disk%:\\portablegit\\bin; set path2=c:\\Windows\\Microsoft.NET\\Framework\\v3.5;%Disk%:\\python-3.5.3-embed-amd64\\Lib\\site-packages; set path3=\"C:\\Program Files (x86)\\Google\\Chrome\\Application\" path=%path%;%path1%;%path2%;%path3% start /MIN %Disk%:\\wscite\\SciTE.exe start /MIN cmd.exe start /MIN cmd.exe start /MIN cmd.exe REM 啟動 Leo 編輯器 REM %Disk%:\\Miniconda3\\python.exe %Disk%:\\apps\\launchLeo.py REM 啟動 stunnel start /MIN fossil.exe server -P 127.0.0.1:8080 %Disk%:\\tmp\\fossil_repo\\vcp.fossil REM 取得電腦 IP, 然後設定 %Disk%:/stunnel/config/stunnel.conf for /f \"delims=[] tokens=2\" %%a in ('ping -4 -n 1 %ComputerName% &#94;| findstr [') do set NetworkIP=%%a REM echo Network IP: %NetworkIP% REM Saved in %Disk%:\\stunnel\\config\\stunnel.conf @echo off REM 建立 stunnel.conf @echo [https] > %Disk%:\\stunnel\\config\\stunnel.conf REM 附加資料 @echo accept = %NetworkIP%:443 >> %Disk%:\\stunnel\\config\\stunnel.conf @echo connect = 127.0.0.1:8080 >> %Disk%:\\stunnel\\config\\stunnel.conf @echo TIMEOUTclose = 0 >> %Disk%:\\stunnel\\config\\stunnel.conf @echo cert = %Disk%:\\stunnel\\config\\localhost.crt >> %Disk%:\\stunnel\\config\\stunnel.conf @echo key = %Disk%:\\stunnel\\config\\localhost.key >> %Disk%:\\stunnel\\config\\stunnel.conf REM 啟動 stunnel start /MIN stunnel.exe REM 以 chrome 連線到 https://%NetworkIP%:443 chrome https://%NetworkIP% Exit","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017spring-stunnel-fossil.html"},{"title":"Ubuntu 16.04 環境下安裝 Ethercalc","text":"說明如何在 Ubuntu 16.04 操作系統中安裝 Ethercalc, 並令其開機時啟動. 安裝 node.js 6.x 版 curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash - sudo apt-get install -y nodejs 安裝 redis server sudo apt install redis-server 安裝 ethercalc sudo npm i -g ethercalc 編輯 /etc/rc.local 加入 ethercalc 啟動指令 重新開機後, 就可以利用 http://your ip or domain name:8000 連接 Ethercalc 網頁","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-2017spring-ubuntu-ethercalc.html"},{"title":"網際 Python3 程式環境","text":"網際內容管理課程利用 Brython 建立一個能夠直接在瀏覽器中執行的 Python3 程式環境, 讓使用者進行各種與機械產品開發相關的設計運算與動靜態模擬. window.onload=function(){ brython(1); } from browser import document, html container1 = document['container1'] 利用伺服器執行 Python3 程式 Jupyterhub: https://8888.kmol.info:9443 利用以下的編輯器執行 Python3 程式 在 Firefox 中, 以 Preferences - General - Downloads 選擇\"Always ask me where to save files\" 在 Chrome 中, 以 Settings - Advanced - Downloads 選擇 Ask where to save each file before downloading function doSave(){ var blob = new Blob([localStorage[\"py_src\"]], {type: \"text/plain;charset=utf-8\"}); filename = document.getElementById('filename').value saveAs(blob, filename+\".py\"); } import sys import time import traceback import javascript from browser import document as doc, window, alert has_ace = True try: editor = window.ace.edit(\"editor\") session = editor.getSession() session.setMode(\"ace/mode/python\") editor.setOptions({ 'enableLiveAutocompletion': True, 'enableSnippets': True, 'highlightActiveLine': False, 'highlightSelectedWord': True }) except: from browser import html editor = html.TEXTAREA(rows=20, cols=70) doc[\"editor\"] <= editor def get_value(): return editor.value def set_value(x):editor.value = x editor.getValue = get_value editor.setValue = set_value has_ace = False if hasattr(window, 'localStorage'): from browser.local_storage import storage else: storage = None def reset_src(): if storage is not None and \"py_src\" in storage: editor.setValue(storage[\"py_src\"]) else: editor.setValue('for i in range(10):\\n\\tprint(i)') editor.scrollToRow(0) editor.gotoLine(0) def reset_src_area(): if storage and \"py_src\" in storage: editor.value = storage[\"py_src\"] else: editor.value = 'for i in range(10):\\n\\tprint(i)' class cOutput: def __init__(self,target): self.target = doc[target] def write(self,data): self.target.value += str(data) #if \"console\" in doc: sys.stdout = cOutput(\"console\") sys.stderr = cOutput(\"console\") def to_str(xx): return str(xx) info = sys.implementation.version doc['version'].text = 'Brython %s.%s.%s' % (info.major, info.minor, info.micro) output = '' def show_console(ev): doc[\"console\"].value = output doc[\"console\"].cols = 60 doc[\"console\"].rows = 10 # load a Python script def load_script(evt): _name = evt.target.value + '?foo=%s' % time.time() editor.setValue(open(_name).read()) # run a script, in global namespace if in_globals is True def run(*args): global output doc[\"console\"].value = '' src = editor.getValue() if storage is not None: storage[\"py_src\"] = src t0 = time.perf_counter() try: #ns = {'__name__':'__main__'} ns = {'__name__':'editor'} exec(src, ns) state = 1 except Exception as exc: traceback.print_exc(file=sys.stderr) state = 0 output = doc[\"console\"].value print('<completed in %6.2f ms>' % ((time.perf_counter() - t0) * 1000.0)) return state if has_ace: reset_src() else: reset_src_area() def clear_console(ev): doc[\"console\"].value = \"\" doc['run'].bind('click',run) doc['show_console'].bind('click',show_console) doc['clear_console'].bind('click',clear_console) Filename: .py Run Output 清除 from browser import document as doc import script1 def ex1(ev): script1.editor.setValue('''#ex1 簡單的 for 迴圈範例 for i in range(10): print(i) ''') script1.editor.scrollToRow(0) script1.editor.gotoLine(0) doc['ex1'].bind('click',ex1) ex1 -for 迴圈 from browser import document as doc import script1 def ex2(ev): script1.editor.setValue('''#溫度轉換程式 from browser import document as doc # 因為此函式與滑鼠互動, 需要 event 當作輸入 def convTemp(): mystring = \"\" cdegree = input(\"請輸入攝氏溫度:\") fdegree = float(cdegree)*9/5 + 32 output_string = \"攝氏 \" + str(cdegree) + \"度=華氏 \" + str(fdegree) + \"度\" # 利用 print() 將轉換結果送到 console 區 print(output_string) #直接呼叫 convTemp() 執行 convTemp() ''') script1.editor.scrollToRow(0) script1.editor.gotoLine(0) doc['ex2'].bind('click',ex2) ex2 -溫度換算 from browser import document import script1 def get_file(e): data = open(\"./../python_ex/for1.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"get\"].bind(\"click\", get_file) from browser import document import script1 def get_temp1(e): data = open(\"./../python_ex/temp1.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"get_temp1\"].bind(\"click\", get_temp1) from browser import document import script1 def get_ver_and_kw(e): data = open(\"./../python_ex/ver_and_kw.py\").read() script1.editor.setValue(data) script1.editor.scrollToRow(0) script1.editor.gotoLine(0) document[\"get_ver_and_kw\"].bind(\"click\", get_ver_and_kw) for1.py temp1.py ver_and_kw.py","tags":"Course","url":"https://scrum-1.github.io/scrum_pyqt5_calculator/blog/kmol-web-based-python3.html"}]};